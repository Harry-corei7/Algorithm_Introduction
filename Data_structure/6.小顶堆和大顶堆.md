**小顶堆和大顶堆--- Java中的有序队列PriorityQueue**

`1.概念`

| 类型 | 行为
|---|---
| 小顶堆 | 堆顶是最小元素(默认行为)
| 大顶堆 | 堆顶是最大元素(需定义lamda表达式比较器)

`2.小顶堆-升序`

```java
import java.util.*;

public class MinHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        minHeap.offer(5);
        minHeap.offer(1);
        minHeap.offer(3);

        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " ");
        }
        // 输出：1 3 5
    }
}
```

`3.大顶堆-降序`

```java
import java.util.*;

public class MaxHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); // 降序比较

        maxHeap.offer(5);
        maxHeap.offer(1);
        maxHeap.offer(3);

        while (!maxHeap.isEmpty()) {
            System.out.print(maxHeap.poll() + " ");
        }
        // 输出：5 3 1
    }
}

```

---

`4.Lamda公式介绍`

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
maxHeap.offer(5);
maxHeap.offer(1);
maxHeap.offer(3);
// 输出 5 3 1
```

```java
PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
pq.offer(new int[]{5, 3});
pq.offer(new int[]{7, 1});
pq.offer(new int[]{9, 2});
// 输出 [7,1] [9,2] [5,3]
```

---

`5.常见案例代码`

`5.1 Top K 个最大元素（大顶堆）`

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

for (int num : nums) {
    maxHeap.offer(num);
}
// 取出前 K 个
for (int i = 0; i < k; i++) {
    res[i] = maxHeap.poll();
}
```

`5.2 Top K 个最小元素（小顶堆）`

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

for (int num : nums) {
    maxHeap.offer(num);
}
// 取出前 K 个
for (int i = 0; i < k; i++) {
    res[i] = maxHeap.poll();
}
```

`5.3 频率统计（堆存二元组）`

```java
Map<Integer, Integer> freq = new HashMap<>();
for (int num : nums) freq.put(num, freq.getOrDefault(num, 0) + 1);

// 小顶堆：保留频率最高的 K 个元素
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);

for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
    pq.offer(new int[]{entry.getKey(), entry.getValue()});
    if (pq.size() > k) pq.poll(); // 保证堆大小为 k
}
```
