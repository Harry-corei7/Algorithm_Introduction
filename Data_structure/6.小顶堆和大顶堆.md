**小顶堆和大顶堆--- Java中的有序队列PriorityQueue**

`1.概念`

| 类型 | 行为
|---|---
| 小顶堆 | 堆顶是最小元素(默认行为)
| 大顶堆 | 堆顶是最大元素(需定义lamda表达式比较器)

`2.小顶堆-升序`

```java
import java.util.*;

public class MinHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        minHeap.offer(5);
        minHeap.offer(1);
        minHeap.offer(3);

        while (!minHeap.isEmpty()) {
            System.out.print(minHeap.poll() + " ");
        }
        // 输出：1 3 5
    }
}
```

`3.大顶堆-降序`

```java
import java.util.*;

public class MaxHeapExample {
    public static void main(String[] args) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); // 降序比较

        maxHeap.offer(5);
        maxHeap.offer(1);
        maxHeap.offer(3);

        while (!maxHeap.isEmpty()) {
            System.out.print(maxHeap.poll() + " ");
        }
        // 输出：5 3 1
    }
}

```

---

`4.Lamda公式介绍`

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
maxHeap.offer(5);
maxHeap.offer(1);
maxHeap.offer(3);
// 输出 5 3 1
```

```java
PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
pq.offer(new int[]{5, 3});
pq.offer(new int[]{7, 1});
pq.offer(new int[]{9, 2});
// 输出 [7,1] [9,2] [5,3]
```

---

`5.常见案例代码`

`5.1 Top K 个最大元素（大顶堆）`

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

for (int num : nums) {
    maxHeap.offer(num);
}
// 取出前 K 个
for (int i = 0; i < k; i++) {
    res[i] = maxHeap.poll();
}
```

`5.2 Top K 个最小元素（小顶堆）`

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

for (int num : nums) {
    maxHeap.offer(num);
}
// 取出前 K 个
for (int i = 0; i < k; i++) {
    res[i] = maxHeap.poll();
}
```

`5.3 频率统计（堆存二元组）`

```java
Map<Integer, Integer> freq = new HashMap<>();
for (int num : nums) freq.put(num, freq.getOrDefault(num, 0) + 1);

// 小顶堆：保留频率最高的 K 个元素
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);

for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
    pq.offer(new int[]{entry.getKey(), entry.getValue()});
    if (pq.size() > k) pq.poll(); // 保证堆大小为 k
}
```

`5.4 HasMap遍历`

`5.4.1 Map.Entry<Integer, Integer>`

```java
Map<Integer, Integer> freq = new HashMap<>();
freq.put(3, 5); // 数字3出现了5次
freq.put(2, 1); // 数字2出现了1次
```

1) 在 Map<Integer, Integer> 中：
- key: 表示元素（例如数字）
- value: 表示元素出现的次数（frequency）

2) 在Map.Entry<Integer, Integer> 表示：
- 一组键值对：比如 (3, 5)

`5.4.2 entry : freq.entrySet()`

```java
for (Map.Entry<Integer, Integer> entry : freq.entrySet())
```
1) 这是 Java 中用于遍历 Map 的推荐写法，相当于：
- 遍历 freq 这个 Map 中的每一个 entry（键值对）
- freq.entrySet() 返回所有 Map.Entry<K, V> 的集合
- 每次循环中 entry 是一个 Map.Entry

`5.4.3 entry.getKey() 和 entry.getValue()`

| 方法 | 意义
|--- |---
| entry.getKey() | 获取当前这对 entry 的 key（比如是某个数字）
| entry.getValue() | 获取当前 entry 的 value（比如是它出现的次数）
	
	
entry.getValue()	获取当前 entry 的 value（比如是它出现的次数）
