`难度：中等`

- 给你一个整数数组`nums`，数组中的元素`互不相同`。返回该数组所有可能的子集（幂集）。
- 数组的`子集`是从数组中选择一些元素（可能为空）。
- 解集`不能`包含重复的子集。你可以按`任意顺序`返回解集。

- 示例 1：
  - 输入：nums = [1,2,3]
  - 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
- 示例 2：
  - 输入：nums = [0]
  - 输出：[[],[0]]
---
- 如果把`子集问题`、`组合问题`、`分割问题`都抽象为一棵树的话，
- **那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**

<img width="900" height="550" alt="image" src="https://github.com/user-attachments/assets/7a43fb53-9aa9-4025-80d8-adbda2ebc539" />

- **从图中红线部分，可以看出遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合。**

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, nums, result, path, startIndex):
        if(startIndex >= len(nums)): # 注意"终止条件": 其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了。
            # result.append(path[:])
            # 组合问题/分割问题：收集叶子节点(最下层的节点，即最后的"方案"，"结果")
            return
        for i in range(startIndex, len(nums)):
            path.append(nums[i])
            result.append(path[:]) # 子集问题：遍历树，收集每一个节点
            self.backtracking(nums, result, path, i+1)
            path.pop(-1)
            

    
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        path = []
        self.backtracking(nums, result, path, 0)
        result.append([]) # 记得补上空集
        return result
```
