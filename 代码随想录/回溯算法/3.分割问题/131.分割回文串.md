`难度：中等`

> 为什么说 **其实切割问题类似组合问题**
- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。

- 所以切割问题，也可以抽象为一棵树形结构，如图：

<img width="900" height="540" alt="image" src="https://github.com/user-attachments/assets/ddc5f8df-c6f3-4479-8da3-cd90cdb9fda1" />

> 递归三部曲

#### 1.递归函数参数
- 全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）
- 本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。

<img width="900" height="540" alt="image" src="https://github.com/user-attachments/assets/ddc5f8df-c6f3-4479-8da3-cd90cdb9fda1" />

#### 2.递归函数终止条件
- 从树形结构的图中可以看出：
  - 切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。

- 那么在代码里**什么是切割线呢？**
  - 在处理组合问题的时候，递归参数需要传入startIndex
  - 表示下一轮递归遍历的起始位置，这个startIndex就是切割线。

- 所以终止条件代码如下：
```python
def backtracking(self, s, result, path, startIndex):
    if(startIndex >= len(s)):
        result.append(path[:])
        return
```

#### 3.单层搜索的逻辑

- **来看看在递归循环中如何截取子串呢？**
  - 在for (int i = startIndex; i < s.size(); i++)循环中，我们定义了 `起始位置startIndex`
  - 那么 [startIndex, i] 就是要截取的子串。
  - 首先判断这个子串是不是回文，如果是回文，就加入在`vector<string> path`中，path用来记录切割过的回文子串。

- 所以搜索代码如下：
```python
for i in range(startIndex, len(s)):
    if(self.isPalindrome(s, startIndex, i)): # 是回文子串
        # 获取[startIndex,i]在s中的子串
        path.append(s[startIndex:i+1]) 
    else:
        continue # 如果不是则直接跳过
    self.backtracking(s, result, path, i+1) # 寻找i+1为起始位置的子串 
    path.pop(-1) # 回溯
```

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, s, result, path, startIndex):
        if(startIndex >= len(s)):
            result.append(path[:])
            return
        
        for i in range(startIndex, len(s)):
            if(self.isPalindrome(s, startIndex, i)):
                path.append(s[startIndex : i+1])
            else:
                continue
            self.backtracking(s, result, path, i+1)
            path.pop(-1)

    # 判断"字符串"是否为"回文"
    def isPalindrome(self, s, start, end):
        i = start
        j = end
        while(i < j):
            if(s[i] != s[j]):
                return False
            i += 1
            j -= 1
        return True


    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        result = []
        path = []
        self.backtracking(s, result, path, 0)
        return result
```
