`难度：中等`

- 给你一个整数数组`nums`，数组中的元素`互不相同`。返回该数组所有可能的子集（幂集）。
- 数组的`子集`是从数组中选择一些元素（可能为空）。
- 解集`不能`包含重复的子集。你可以按`任意顺序`返回解集。

- 示例 1：
  - 输入：nums = [1,2,3]
  - 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
- 示例 2：
  - 输入：nums = [0]
  - 输出：[[],[0]]
---
- 如果把`子集问题`、`组合问题`、`分割问题`都抽象为一棵树的话，
- 那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！

<img width="900" height="550" alt="image" src="https://github.com/user-attachments/assets/7a43fb53-9aa9-4025-80d8-adbda2ebc539" />


---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, nums, result, path, startIndex):
        if(startIndex >= len(nums)): # 注意"终止条件": startIndex已经大于数组的长度了，就终止了，因为没有元素可取了 
            return
        for i in range(startIndex, len(nums)):
            path.append(nums[i])
            result.append(path[:])
            self.backtracking(nums, result, path, i+1)
            path.pop(-1)
            

    
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        path = []
        self.backtracking(nums, result, path, 0)
        result.append([]) # 记得补上空集
        return result
```
