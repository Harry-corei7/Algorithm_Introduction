`难度：中等`

- 给你一个整数数组`nums`，其中可能包含重复元素，请你返回该数组所有可能的`子集（幂集）`。
- 数组的`子集`是从数组中选择一些元素（可能为空）。
- 解集`不能`包含重复的子集。返回的解集中，子集可以按`任意顺序`排列。

- 示例 1：
  - 输入：nums = [1,2,2]
  - 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
- 示例 2：
  - 输入：nums = [0]
  - 输出：[[],[0]]
---

<img width="900" height="550" alt="image" src="https://github.com/user-attachments/assets/d461d4bf-b82e-4a06-af27-b70535274641" />

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, nums, result, path, startIndex):
        if(startIndex >= len(nums)):
            return
        for i in range(startIndex, len(nums)):
            if(i != startIndex and nums[i] == nums[i-1]): # 当同一层发现重复元素，直接continue
                continue
            path.append(nums[i])
            result.append(path[:])
            self.backtracking(nums, result, path, i+1)
            path.pop(-1)


    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        path = []
        self.backtracking(sorted(nums), result, path, 0)
        result.append([])
        return result
```
