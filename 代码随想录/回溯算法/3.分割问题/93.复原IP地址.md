`难度：中等`

- 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
- 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
- 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

- 示例 1：
  - 输入：s = "25525511135"
  - 输出：["255.255.11.135","255.255.111.35"]

- 示例 2：
  - 输入：s = "0000"
  - 输出：["0.0.0.0"]

- 示例 3：
  - 输入：s = "1111"
  - 输出：["1.1.1.1"]

- 示例 4：
  - 输入：s = "010010"
  - 输出：["0.10.0.10","0.100.1.0"]

- 示例 5：
  - 输入：s = "101023"
  - 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

`提示：`
  - 0 <= s.length <= 3000
  - s 仅由数字组成
---
- 其实只要**意识到这是切割问题，切割问题就可以使用回溯搜索法把所有可能性搜出来**，和刚做过的131.分割回文串 (opens new window)就十分类似了。
- 切割问题可以抽象为树型结构，如图：

<img width="900" height="450" alt="image" src="https://github.com/user-attachments/assets/40d590d8-6cdc-485b-b8a1-79883e515445" />

> 回溯三部曲
#### 1) 递归参数
- `startIndex`一定是需要的，因为`不能重复分割`，记录下一层递归分割的起始位置。
- 本题我们还需要一个变量`pointNum`，记录`添加逗点的数量`。

#### 2) 递归终止条件
- 本题`明确要求只会分成4段`，所以`不能用切割线切到最后`作为终止条件，而是**分割的段数**作为终止条件。
- `pointNum表示逗点数量`，pointNum为3说明字符串分成了4段了。

#### 3) 单层搜索的逻辑
- 在`for (int i = startIndex; i < s.size(); i++)`循环中`[startIndex, i]`这个区间就是截取的子串，需要判断这个子串是否合法。
- 如果合法就在字符串后面加上符号`.`表示已经分割。

<img width="900" height="450" alt="image" src="https://github.com/user-attachments/assets/f7e9d18c-0d95-4f77-b2fe-46d88ee07a76" />

- 然后就是递归和回溯的过程：
- 递归调用时，下一层递归的`startIndex`要从`i+2`开始（因为需要在字符串中加入了`分隔符.`）
- 同时，记录分割符的数量`pointNum`要 +1。
- 回溯的时候，就将刚刚加入的分隔符. 删掉就可以了，pointNum也要-1。
---

> 判断子串是否合法

- 主要考虑到如下三点：
  - **(1) 段位以0为开头的数字不合法**
```python
if(s[start] == "0" and start > end):
    return False
```
  - **(2) 段位里有非正整数字符不合法**
```python
for i in range(start, end+1):
    if(s[i] < "0" or s[i] > "9"):
        return False
```
  - **(3) 段位如果大于255了不合法**
```python
num = 0
for i in range(start, end+1):
    num = num*10 + int(s[i])
    if(num > 255):
        return False
# start=0, end=3
# 循环：
#     i=0: num=0*10+1=1 (≤255)
#     i=1: num=1*10+9=19 (≤255)
#     i=2: num=19*10+2=192 (≤255)
```

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, s, result, startIndex, pointNum):
        if(pointNum == 3): # 逗号数量为3，结束循环
            if(self.isValid(s, startIndex, len(s)-1)): # 判断第四段子字符串是否合法，如果合法就放进result中
                result.append(s) # 所以是直接在s上修改了？不，这里的是s_new
                return
        
        for i in range(startIndex, len(s)):
            if(self.isValid(s, startIndex, i)):
                s_list = list(s)
                s_list.insert(i + 1, '.')
                s_new = ''.join(s_list) # 创建的新的s, 带'.'
                
                pointNum += 1
                self.backtracking(s_new, result, i + 2, pointNum)  # 下一个子串起始位置为i+2，因为i+1为'.'
                pointNum -= 1  # 回溯
                # 我们创建了新的字符串s_new传给递归，原s保持不变
            else:
                break  # 为什么是break? 因为如果不Valid，这一层后面都不Valid


    def isValid(self, s, start, end):
        if start > end: # 这一步咋来的？举个例子["255255111"]：255.255.111.  "."已经是len(s)-1了，i+2就是len(s)
            return False
        if(s[start] == "0" and (start != end)):
            return False # 0开头的数字不合法
        num = 0
        for i in range(start, end+1):
            if(s[i] < '0' or s[i] > '9'):
                return False # 遇到非数字字符不合法
            num = num*10 + int(s[i])
            if(num > 255):
                return False # 如果大于255了不合法
            # start=0, end=3
            # 循环：
            #     i=0: num=0*10+1=1 (≤255)
            #     i=1: num=1*10+9=19 (≤255)
            #     i=2: num=19*10+2=192 (≤255)
        return True
            

    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        result = []
        self.backtracking(s, result, 0, 0)
        return result
```
