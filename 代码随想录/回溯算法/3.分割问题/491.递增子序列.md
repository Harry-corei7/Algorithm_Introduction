`难度：中等`

- 给你一个整数数组`nums`，找出并返回所有该数组中不同的递增子序列，递增子序列中`至少有两个元素`。
- 你可以按`任意顺序`返回答案。
- 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

- 示例 1：
  - 输入：nums = [4,6,7,7]
  - 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
- 示例 2：
  - 输入：nums = [4,4,3,2,1]
  - 输出：[[4,4]]
---
> 回溯三部曲

#### (1) 递归函数参数

- 本题求子序列，很明显一个元素不能重复使用，所以需要`startIndex`，调整下一层递归的起始位置。
- 代码如下
```python
result = []
path = []
self.backtracking(nums, result, path, 0) # startIndex参数
```

#### (2) 终止条件

- 本题其实`类似求子集问题`，也是要遍历树形结构找`每一个节点`
  - 所以和回溯算法：求子集问题一样，可以`不加终止条件(没有return)`，`startIndex每次都会加1`，并不会无限递归。
- 但本题`收集结果有所不同`，题目要求递增子序列大小至少为2
- 所以代码如下：
```python
if(len(path) == 2):
    result.append(path[:])
    # 注意这里不要加return，因为要取树上的所有节点(类似子集问题，取到所有节点)
```

#### (3) 单层搜索逻辑

<img width="900" height="550" alt="image" src="https://github.com/user-attachments/assets/6c0f01fe-0ee7-4ce6-81b0-9a7e2b5d1a85" />

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, nums, result, path, startIndex):
        if(len(path) >= 2):
            result.append(path[:])
        used = [] # 记录本层已经使用过的元素，写在这里就行，不用全局变量
        for i in range(startIndex, len(nums)):
            if((len(path) != 0 and nums[i] < path[-1]) or (nums[i] in used)): # 条件如何设置？
            # (1)当序列不为空，所取元素不小于序列最后一个元素 
            # (2)同一父节点同一层相同元素不得重复使用，举例(4767)，最后一个7不能用
                continue
            used.append(nums[i]) # 记录这个元素在在该层使用过了，本层不能再使用了
            path.append(nums[i])
            self.backtracking(nums, result, path, i+1)
            path.pop(-1)
            

    def findSubsequences(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        path = []
        # 不能对nums进行排序，因为题目就是让找nums中的递增子序列
        self.backtracking(nums, result, path, 0)
        return result
```
