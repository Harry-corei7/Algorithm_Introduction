`难度：中等`

- 给定两个整数`n`和`k`，返回范围`[1, n]`中所有可能的`k`个数的组合。
- 你可以按`任何顺序`返回答案。

- 示例 1：
- 输入：n = 4, k = 2
- 输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

- 示例 2：
- 输入：n = 1, k = 1
- 输出：[[1]]

---
> 回溯法三部曲

### 1.递归函数的返回值以及参数
- 在这里要定义`两个全局变量`，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。
```python
result : List[List[int]] = []; // 存放符合条件结果的集合
path : List[int] = []; // 用来存放符合条件结果
```
- 函数里一定有两个参数，既然是集合n里面取k个数，那么n和k是两个int型的参数。
- 然后还需要一个参数，为int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
- 所以需要startIndex来记录下一层递归，搜索的起始位置。
- 那么整体代码如下：
```python
result : List[List[int]] = [] # 存放符合条件结果的集合
path : List[int] = [] # 用来存放符合条件结果
backtracking(n, k, startIndex, result, path)
```

<img width="900" height="450" alt="image" src="https://github.com/user-attachments/assets/8b63e452-bd76-418b-9fef-3ad36a0dad8d" />

### 2.回溯函数终止条件
- 什么时候到达所谓的叶子节点了呢？
- `path这个数组的大小如果达到k`，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径
- 此时用result二维数组，把path保存起来，并终止本层递归。
- 终止条件代码如下：
```python
if (len(path) == k):
    result.append(path[:]) # 常见的错误，append(path),而不是path[:]
    return
```

<img width="900" height="450" alt="image" src="https://github.com/user-attachments/assets/c687e8bc-665a-405b-a7bf-0fa11e3b16f5" />

`关于常见错误，path引用讲解`
```python
result.append(path)  # 注意：这里添加的是 path 的引用，不是值的复制
print(f"添加后: result = {result}")  # [[1, 2]]

# 回溯（准备找下一个组合）
path.pop()  # 移除 2
path.pop()  # 移除 1
print(f"回溯后: path = {path}")  # []
```

### 3.单层搜索的过程
- 回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。
- for循环每次从startIndex开始遍历，然后用path保存取到的节点i。
```python
for i in range(startIndex, n+1): # 控制树的横向遍历
    path.append(i) # 处理节点
    self.backtracking(n, k, i+1, result, path) # 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop() # 回溯，撤销处理的节点
```

<img width="900" height="450" alt="image" src="https://github.com/user-attachments/assets/36b591b5-89c2-4e54-9f3c-c6a3af52c498" />


---
`python语法：递归回溯法(未剪枝版本)`
```python
class Solution(object):
    def backtracking(self, n, k, startIndex, result, path):
        if(len(path) == k):
            result.append(path[:])
            return
        for i in range(startIndex, n+1): # 控制树的横向遍历
            path.append(i) # 处理节点
            self.backtracking(n, k, i+1, result, path) # 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
            path.pop() # 回溯，撤销处理的节点


    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        result = [] # 二位数组，存放集合结果
        path = [] # 存放节点
        self.backtracking(n, k, 1, result, path)
        return result
```
`python语法：递归回溯法(剪枝优化版本)`
