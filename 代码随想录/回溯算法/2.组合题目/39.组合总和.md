`难度：中等`

- 给你一个`无重复元素`的整数数组`candidates`和一个目标整数`target`，找出`candidates`中可以使数字和为目标数`target`的**所有**不同组合 ，并以列表形式返回。
- 你可以按`任意顺序`返回这些组合。
- `candidates`中的`同一个`数字可以`无限制重复被选取`。
- 如果至少一个数字的被选数量不同，则两种组合是不同的。 
- **温馨提示:** 对于给定的输入，保证和为 target 的不同组合数少于 150 个。

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, candidates, target, result, path, startIndex):
        if(sum(path) > target): # 写在for循环里，会提前终止同一层的遍历
            return              # 写在这里，只会在下一层终止，不影响同一层后续遍历
        elif(sum(path) == target): 
            result.append(path[:])
            return
        for i in range(startIndex, len(candidates)):
            path.append(candidates[i])
            self.backtracking(candidates, target, result, path, i) # 相较于77，可以有相同的字母，所以是i，不是i+1
            path.pop(-1)
        

    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        result = []
        path = []
        self.backtracking(candidates, target, result, path, 0)
        return result
```
