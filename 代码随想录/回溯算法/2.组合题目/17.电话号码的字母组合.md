`难度：中等`

- 给定一个仅包含数字`2-9`的字符串，返回所有它能表示的字母组合。答案可以按`任意顺序`返回。
- 给出数字到字母的映射如下（与电话按键相同）。
- 注意`1`不对应任何字母。

<img width="500" height="600" alt="image" src="https://github.com/user-attachments/assets/af4596e6-b68f-4a3f-bfe9-8ba81151ff78" />

- 示例:
- 输入："23"
- 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
- 说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。


---
`python语法：递归回溯法(自创版)`
```python
class Solution(object):
    def backtracking(self, digits, result, path, digits_dict, startIndex):
        if(len(path) == len(digits)):
            str_path = ''.join(path) # List转化为str
            result.append(str_path) # 添加结果
            return
        for i in range(0, len(digits_dict[int(digits[startIndex])])): # 当前层的横向for循环
            path.append(digits_dict[int(digits[startIndex])][i])
            startIndex += 1 # 向下递归
            self.backtracking(digits, result, path, digits_dict, startIndex) # 开启下一层的横向for循环
            startIndex -= 1 # 回溯
            path.pop(-1) # 回溯


    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        # 创建结果列表
        result = []
        path = []
        startIndex = 0 # startIndex的作用：递进到下一个集合(下一层)，开始新的for循环

        # 创建数字字母列表，便于提取对应字母
        digits_dict = {}
        words_char = "abcdefghijklmnopqrstuvwxyz"
        for i in range(2, 7):
            digits_dict[i] = words_char[(i-2)*3 : (i-1)*3]
        digits_dict[7] = "pqrs"
        digits_dict[8] = "tuv"
        digits_dict[9] = "wxyz"

        # 调用递归回溯函数
        self.backtracking(digits, result, path, digits_dict, startIndex)
        return result
```
