`难度：中等`

- 给定一个候选人编号的集合`candidates`和一个目标数`target`，找出`candidates`中所有可以使数字和为`target`的组合。
- `candidates`中的每个数字在每个组合中只能使用**一次**。

- 示例 1:
- 输入: candidates = [10,1,2,7,6,1,5], target = 8,
- 输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

- 示例 2:
- 输入: candidates = [2,5,2,1,2], target = 5,
- 输出:
[
[1,2,2],
[5]
]
---
``

---
`python语法：递归回溯法(未剪枝版)`
```python
class Solution(object):
    def backtracking(self, candidates, target, result, path, startIndex):
        if(sum(path) > target):
            return
        elif(sum(path) == target):
            if(path not in result):
                result.append(path[:])
            return
        for i in range(startIndex, len(candidates)):
            path.append(candidates[i])
            self.backtracking(candidates, target, result, path, i+1)
            path.pop(-1)

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        result = []
        path = []
        self.backtracking(sorted(candidates), target, result, path, 0)
        return result
```
