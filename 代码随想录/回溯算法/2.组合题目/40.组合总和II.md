`难度：中等`

- 给定一个候选人编号的集合`candidates`和一个目标数`target`，找出`candidates`中所有可以使数字和为`target`的组合。
- `candidates`中的每个数字在每个组合中只能使用**一次**。

- 示例 1:
- 输入: candidates = [10,1,2,7,6,1,5], target = 8,
- 输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

- 示例 2:
- 输入: candidates = [2,5,2,1,2], target = 5,
- 输出:
[
[1,2,2],
[5]
]
---
> 剪枝优化2
- **本题的难点在于区别(组合总和III)中：集合（数组candidates）有重复元素，但还不能有重复的组合。**
    - 一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！
    - 所以要在搜索的过程中就去掉重复组合。(去重)

- **所谓去重，其实就是使用过的元素不能重复选取。**
    - 那么“使用过”在这个树形结构上是有两个维度的:
    - 一个维度是**同一树枝上**使用过，一个维度是**同一树层上**使用过。

- **回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。**
    - 所以我们要去重的是**同一树层上的“使用过”**，**同一树枝上**的都是一个组合里的元素，不用去重。
    - **树层去重的方法**
        - `(1) 需要对数组排序`
        - `(2) 排序后，在for循环中，如果当前元素与上一个元素相同，continue(跳过)`

- 来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）

<img width="850" height="500" alt="image" src="https://github.com/user-attachments/assets/f7a65dbf-4566-429a-a295-1bd098849e17" />

---
`python语法：递归回溯法(未剪枝版)`
```python
class Solution(object):
    def backtracking(self, candidates, target, result, path, startIndex):
        if(sum(path) > target):
            return
        elif(sum(path) == target):
            if(path not in result):
                result.append(path[:])
            return
        for i in range(startIndex, len(candidates)):
            path.append(candidates[i])
            self.backtracking(candidates, target, result, path, i+1) # i+1，因为`candidates`中的每个数字只能用一次
            path.pop(-1)

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        result = []
        path = []
        self.backtracking(sorted(candidates), target, result, path, 0)
        return result
```
