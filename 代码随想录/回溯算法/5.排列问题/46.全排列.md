`难度：中等`

- 给定一个不含重复数字的数组`nums`，返回其`所有可能的全排列`。你可以`按任意顺序`返回答案。

- 示例 1：
  - 输入：nums = [1,2,3]
  - 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
- 示例 2：
  - 输入：nums = [0,1]
  - 输出：[[0,1],[1,0]]
- 示例 3：
  - 输入：nums = [1]
  - 输出：[[1]]
---

> 回溯三部曲

#### (1) 递归函数参数

- **首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。**
- 可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理**排列问题就不用使用startIndex了**。
- 但排列问题`需要一个used数组`，标记已经选择的元素，如图橘黄色部分所示:

#### (2) 递归终止条件

<img width="900" height="550" alt="image" src="https://github.com/user-attachments/assets/a7e5d047-ccd8-404e-abe0-4a83b3ab3f53" />

- 可以看出叶子节点，就是收割结果的地方。
- 那么什么时候，算是到达叶子节点呢？
- 当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

#### (3) 单层搜索的逻辑

- 因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。
- **而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。**

`使用used字典记录每个位置的元素是否被使用过`
```python
def backtracking(self, nums, result, path, used):
    # ......
    for i in range(0, len(nums)):
        if(used[i] == True): continue # 如果被在该分支上层被使用过，直接跳过
        used[i] = True
        path.append(nums[i])
        # 回溯....
        path.pop(-1) # 回溯
        used[i] = False # 回溯

def permute(self, nums):
    # ......
    for i in range(0, len(nums)):
        used[i] = False
```

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtarcking(self, nums, result, path, used):
        if(len(path) == len(nums)):
            result.append(path[:])
            return
        for i in range(0, len(nums)):
            # 由于不能漏过任何元素，每次遍历都从0开始，利用used记录是否元素使用过
            if(used[i] == True): # 如果当前位置元素被用过，就跳过
                continue
            used[i] = True
            path.append(nums[i])
            self.backtarcking(nums, result, path, used)
            path.pop(-1)
            used[i] = False


    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        path = []
        used = {}
        for i in range(0, len(nums)):
            used[i] = False # 设置全局变量used字典，记录nums每一个位置的元素是否被使用
        self.backtarcking(nums, result, path, used) # 不设置startIndex，因为元素会被重复使用
        return result
```
