`难度：中等`

- 给定一个可包含重复数字的序列`nums`，按`任意顺序`返回所有`不重复`的全排列。

- 示例 1：
  - 输入：nums = [1,1,2]
  - 输出：[[1,1,2],[1,2,1],[2,1,1]]

- 示例 2：
  - 输入：nums = [1,2,3]
  - 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, nums, result, path, used):
        if(len(path) == len(nums)):
            result.append(path[:])
            return
        used_row = [] # 非全局变量，每一层的used_row都是新的，不同的
        for i in range(0, len(nums)):
            if(used[i] == True or nums[i] in used_row): continue
            used[i] = True
            used_row.append(nums[i]) # 添加本层使用的元素，且不用回溯
            path.append(nums[i])
            self.backtracking(nums, result, path, used)
            # 回溯
            path.pop(-1)
            used[i] = False


    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = []
        path = []
        used = {}
        for i in range(0, len(nums)):
            used[i] = False
        self.backtracking(nums, result, path, used)
        return result
```
