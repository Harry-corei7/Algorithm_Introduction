`难度：困难`

- 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
- `n 皇后问题`研究的是如何将`n`个皇后放置在`n×n`的棋盘上，并且使皇后彼此之间不能相互攻击。
- 给你一个整数`n`，返回所有不同的`n 皇后问题`的解决方案。
- 每一种解法包含一个不同的`n 皇后问题`的棋子放置方案，该方案中`'Q'`和`'.'`分别代表了皇后和空位。

- 示例 1：

<img width="722" height="322" alt="image" src="https://github.com/user-attachments/assets/3e4b1102-1a9d-4b96-993f-45a37a4db2f7" />

  - 输入：n = 4
  - 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
  - 解释：如上图所示，4 皇后问题存在两个不同的解法。

- 示例 2：
  - 输入：n = 1
  - 输出：[["Q"]]

---

> 回溯三部曲

#### (1) 递归函数参数

- 我依然是定义全局变量二维数组result来记录最终结果。
- 参数`n`是棋盘的大小，然后用`row`来记录当前遍历到`棋盘的第几层`了。
  - 有点类似startIndex，但是`逻辑完全不一样`

#### (2) 递归终止条件

<img width="900" height="600" alt="image" src="https://github.com/user-attachments/assets/587ebad0-0193-4e5d-a485-380e66f35fb5" />

- **可以看出，当递归到棋盘最底层`(也就是叶子节点)`的时候，就可以收集结果并返回了。**
- 代码如下：
```python
if(row == n):
    # 拷贝必须直接拷贝对应的list，不然会“浅拷贝(拷贝地址而非元素)”
    result.append([row_list[:] for row_list in chessboard])
    return
```

#### (3) 单层搜索的逻辑

- **递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。**
- 每次都是要`从新的一行的起始位置开始搜`，所以都是`从0开始`。
- 代码如下：
```python
for col in range(0, n):
    if(self.isValid(row, col, chessboard, n)):
        chessboard[row][col] = "Q"
        self.backtracking(n, result, chessboard, row+1) # 向下一层递归
        chessboard[row][col] = "." # 回溯
```

---
`验证棋盘位置是否合法`
- 不能同行(不用检查，因为遍历逻辑是逐层遍历)
- 不能同列
- 不能同斜线 （45度和135度角） 

```python
def isValid(self, row, col, chessboard, n):
    # 检查正上方(这一列的上面)
    for i in range(0, row):
        if(chessboard[i][col] == "Q"):
            return False

    # 检查45度左上方
    i = row
    j = col
    while(i <= 0 and j <= 0):
        if(chessboard[i][j] == "Q"):
            return False
        i-=1
        j-=1

    # 检查135度右上方
    i = row
    j = col
    while(i <= 0 and j <= n-1):
        if(chessboard[i][j] == "Q"):
            return False
        i-=1
        j+=1

    return True
```
---
`python语法：递归回溯法`
```python
class Solution(object):
    def backtracking(self, n, result, chessboard, row):
        if(row == n):
            # 拷贝必须直接拷贝对应的List, 不然是"浅拷贝"
            result.append([row_list[:] for row_list in chessboard]) # 这里拷贝了一个新的二维数组
            return
        
        for col in range(0, n):
            if(self.isValid(row, col, chessboard, n)):
                chessboard[row][col] = "Q"
                self.backtracking(n, result, chessboard, row+1)
                chessboard[row][col] = "."


    def isValid(self, row, col, chessboard, n): # row, col为当前准备放入棋盘的Q位置
        # 检查列
        for i in range(0, row):
            if(chessboard[i][col] == "Q"):
                return False
        
        # 检查45%左上角
        i = row - 1
        j = col - 1 
        while(i >= 0 and j >= 0):
            if(chessboard[i][j] == "Q"):
                return False
            i -= 1
            j -= 1
        
        # 检查135%右上角
        i = row - 1
        j = col + 1
        while(i >= 0 and j <= n-1):
            if(chessboard[i][j] == "Q"):
                return False
            i -= 1
            j += 1
        
        return True

    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        result = []
        chessboard = [['.'] * n for i in range(n)] # 初始化棋盘二维数组
        self.backtracking(n, result, chessboard, 0)
        
        # 将二维数组chessboard的转化为一维数组，元素从list转化为str
        for i in range(0, len(result)):
            for j in range(0, n):
                result[i][j] = ''.join(result[i][j])
        return result        
```
