`难度：困难`

- 编写一个程序，通过填充空格来解决数独问题。
- 数独的解法需 遵循如下规则：
  1) 数字`1-9`在每一行只能出现一次。
  2) 数字`1-9`在每一列只能出现一次。
  3) 数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次。（请参考示例图）
- 数独部分空格内已填入了数字，空白格用`'.'`表示。

---
```python
class Solution(object):
    def backtracking(self, board):
        for i in range(0, len(board)): # 遍历棋盘行
            for j in range(0, len(board[0])): # 遍历棋盘列
                if(board[i][j] == '.'):
                    for k in range(1, 10): # (i, j)这个位置放k是否合适
                        if(self.isValid(board, i, j, str(k))):
                            board[i][j] = str(k)
                            if(self.backtracking(board)): # 如果找到合适一组立刻返回？
                                # 因为每一层都进行到这一步，让到下一层，直到最底层叶子(遍历完)，才可能执行return True(遍历完)
                                return True # 相当于提前返回，做个剪枝
                            board[i][j] = '.'
                    return False # 9个数都试完了，都不行，那么就返回false?
                    # 返回False本身重点不是"False"，而是"返回"这个动作->结束其所属的backtracking函数
        return True # 遍历完没有返回false，说明找到了合适棋盘位置了

    
    def isValid(self, board, row, col, val):
        # 检查同一行有没有重复的数字
        for i in range(0, 9):
            if(board[row][i] == val):
                return False

        # 检查同一列有没有重复的数字
        for j in range(0, 9):
            if(board[j][col] == val):
                return False
        
        # 检查同一个9宫格有没有重复的数字
        startRow = (row / 3)* 3 # 锁定所在row的9宫格的起始行
        startCol = (col / 3)* 3 # 锁定所在col的9宫格的起始列
        for i in range(startRow, startRow+3):
            for j in range(startCol, startCol+3):
                if(board[i][j] == val):
                    return False
        
        return True # 三项检查没问题，返回True


    def solveSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: None Do not return anything, modify board in-place instead.
        """
        self.backtracking(board)
        return board
```
