给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

- 输入：x = 4
- 输出：2

示例 2：

- 输入：x = 8
- 输出：2

解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。

---

```java
class Solution {
    public int mySqrt(int x) {
        int left = 0, right = x;
        while(left <= right){
            int mid = left + ((right - left)>>1);
            // 关键点: mid的平方过大导致的整数溢出问题
            if((long)mid*mid == x){
                return mid;
            } 
            // 变体: 由于目标是平方根, 需要下面2种增加判断
            if ((long)mid*mid < x && (long)(mid+1)*(mid+1) > x){
                return mid;
            }
            if ((long)mid*mid > x && (long)(mid-1)*(mid-1) < x){
                return mid-1;
            }
            // 二分法的核心
            if((long)mid*mid > x){
                right = mid -1;
            }
            if((long)mid*mid < x){
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

---

当 x = 2147395599 时，方法返回 -1，说明在二分查找过程中没有触发任何返回条件，最终走到了 return -1。

**原因解析:**
`关键问题：整数溢出`

mid * mid 的计算：
x = 2147395599 的真实平方根是 46339（因为 46339 * 46339 = 2147392921，46340 * 46340 = 2147395600）。

1) 在二分查找过程中，mid 会逐渐逼近 46339 或 46340。
2) 当 mid = 46340 时，mid * mid = 46340 * 46340 = 2147395600。
3) 但 46340 * 46340 的计算结果 2147395600 实际上超过了 int 的最大值 2147483647（即 Integer.MAX_VALUE），导致整数溢出。
4) 溢出后，46340 * 46340 会变成一个负数（因为最高位溢出，变成补码表示的负数），因此 mid * mid > x 的判断会失效。

具体过程：

当 mid = 46340 时：
mid * mid 的正确值是 2147395600，但实际计算会溢出为 -2147477296。

- 此时 mid * mid > x 的判断为 false（因为 -2147477296 < 2147395599），所以不会进入 right = mid - 1 的分支。
- 同时 mid * mid < x 的判断为 true（因为 -2147477296 < 2147395599），所以会进入 left = mid + 1 的分支。

这样，left 会不断向右移动，直到 left > right，最终循环结束，返回 -1。

---

```python
class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        left = 0
        right = x
        while(left <= right):
            mid = (left + right)//2
            if(mid**2 < x):
                left = mid + 1
            if(mid**2 > x):
                right = mid - 1
            if(mid**2 == x):
                return mid
            
            if(mid**2 < x and (mid+1)**2 > x):
                return mid
            if((mid-1)**2 < x and mid**2 > x):
                return (mid-1)
        return -1
```
