给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
示例 2：

输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]

---

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 双指针 - 左右指针法
        // (1) 本质是三指针: 左右指针在原数组相互逼近
        // (2) 满指针(slowIndex)在新的result数组慢慢填充, 而不是在原数组覆盖
        
        // 确定基本元素: 左右+满指针, 新的result数组
        int slowIndex = (nums.length-1);
        int left = 0, right = (nums.length-1);
        int[] result = new int[nums.length];
        
        //  借用二分法的while判断
        while(left <= right){
            if((nums[left] + nums[right]) < 0){
                result[slowIndex] = nums[left] * nums[left];
                left++;
            }
            // 注意: {if, if, if} 和 {if, else if, else if}的区别
            // (1) {if, if, if} 会依次进入三次判断, 三次判断都会进入
            // (2) {if, else if, else if} 讲三次判断看作一个整体, 会进入其中一个判断
            else if((nums[left] + nums[right]) > 0){
                result[slowIndex] = nums[right] * nums[right];
                right--;
            }

            else if((nums[left] + nums[right]) == 0){
                result[slowIndex] = nums[right] * nums[right];
                right--;
            }
            slowIndex--;
        }
        return result;
    }
}
```
