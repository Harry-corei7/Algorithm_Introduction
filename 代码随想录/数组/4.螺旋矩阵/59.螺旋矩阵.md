`难度: 中等`

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

![image](https://github.com/user-attachments/assets/379fa24b-a062-4627-86f2-d2dfd256b381)

输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
示例 2：

输入：n = 1
输出：[[1]]

---

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int count = 1; // 记录矩阵里面要填的数字

        int startX = 0, startY = 0; // 每一圈的起始点
        int loop = 1; // 记录当前圈数
        int offset = 1; // 记录一圈的一层(比如n=4, 最外圈一层就是3)比n少的个数, 随着圈层增大而增大
        int i,j;

        while(n/2 >= loop){ // 根据观察可得n为偶数-总圈数 = n/2, n为奇数-总圈数 = (n-1)/2 
    
            // 上层
            for(j = startY; j < n-offset; j++){ // 左闭右开, j最后的值=n-offset但不执行
                matrix[startX][j] = count;
                count++;
            }
            // 右层
            for(i = startX; i < n-offset; i++){ // 左闭右开, i最后的值=n-offset但不执行
                matrix[i][j] = count;
                count++;
            }
            // 下层
            for(; j > startY; j--){             // 左开右闭, j最后的值=startY但不执行
                matrix[i][j] = count;
                count++;
            }
            // 下层
            for(; i > startX; i--){              // 左开右闭, i最后的值=startX但不执行
                matrix[i][startY] = count;
                count++;
            }
            startY++;
            startX++;
            offset++;
            loop++;
        }
        if(n%2 == 1){ // 单独处理奇数的矩阵中心点
            matrix[startX][startY] = count;
        }
        return matrix;
    }
}
```

