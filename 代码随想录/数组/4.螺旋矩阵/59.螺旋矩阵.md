`难度: 中等`

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

![image](https://github.com/user-attachments/assets/379fa24b-a062-4627-86f2-d2dfd256b381)

输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
示例 2：

输入：n = 1
输出：[[1]]

---

`(1)边界触碰法`

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int [][] matrix = new int[n][n];
        int count = 1;
        // 边界触碰法: 
        // 好处(1)-不用担心while判断条件, 无论矩阵是长方形/正方形, 无论n是奇数或偶数
        // 好处(2)-设置变量数目比较少
        int left = 0, right = n-1, top = 0, bottom = n-1;
        
        while(true){
            // 在top层, 从左往右
            for(int i = left; i <= right; i++){
                matrix[top][i] = count;
                count++;
            }
            if(++top > bottom){ // top+1, 将top下调
                break;
            }
            // 在right层, 从上往下
            for(int i = top; i <= bottom; i++){
                matrix[i][right] = count;
                count++;
            }
            if(--right < left){ // right-1, 将right左调
                break;
            }
            // 在bottom层, 从右往左
            for(int i = right; i >= left; i--){
                matrix[bottom][i] = count;
                count++;
            }
            if(--bottom < top){ // bottom-1, 将bottom上调
                break;
            }
            // 在left层, 从下往上
            for(int i = bottom; i >= top; i--){
                matrix[i][left] = count;
                count++;
            }
            if(++left > right){ // left+1, 将left右调
                break; 
            }
        }
        return matrix;
    }
}
```

---

`(2)左开右闭法`

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int count = 1; // 记录矩阵里面要填的数字

        int startX = 0, startY = 0; // 每一圈的起始点
        int loop = 1; // 记录当前圈数
        int offset = 1; // 记录一圈的一层(比如n=4, 最外圈一层就是3)比n少的个数, 随着圈层增大而增大
        int i,j;

        while(n/2 >= loop){ // 根据观察可得n为偶数-总圈数 = n/2, n为奇数-总圈数 = (n-1)/2 
    
            // 上层
            for(j = startY; j < n-offset; j++){ // 左闭右开, j最后的值=n-offset但不执行
                matrix[startX][j] = count;
                count++;
            }
            // 右层
            for(i = startX; i < n-offset; i++){ // 左闭右开, i最后的值=n-offset但不执行
                matrix[i][j] = count;
                count++;
            }
            // 下层
            for(; j > startY; j--){             // 左开右闭, j最后的值=startY但不执行
                matrix[i][j] = count;
                count++;
            }
            // 下层
            for(; i > startX; i--){              // 左开右闭, i最后的值=startX但不执行
                matrix[i][startY] = count;
                count++;
            }
            startY++;
            startX++;
            offset++;
            loop++;
        }
        if(n%2 == 1){ // 单独处理奇数的矩阵中心点
            matrix[startX][startY] = count;
        }
        return matrix;
    }
}
```

