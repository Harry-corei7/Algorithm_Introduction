`难度: 困难`

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 
示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

示例 2：

输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。

示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。

---
`java语法`
```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public String minWindow(String s, String t) {
        if(s.length() == 0 || t.length() == 0 || t.length() > s.length()){
            return"";
        }
        // (1)创建储存t数组的HashMap
        Map<Character, Integer> target = new HashMap<>();
        // 统计t数组的 1.独特字母 2.独特字母对应的数量
        for(int i = 0; i < t.length(); i++){
            target.put(t.charAt(i), target.getOrDefault(t.charAt(i), 0) + 1);
        }

        // (2)创建储存s数组的HashMap
        Map<Character, Integer> window = new HashMap<>();

        // (3)创建数组result记录符合条件的最小length以及此时left, right位置
        int[] result = {-1, 0, 0};
        int left = 0;

        int required = target.size(); // 需要满足的独特字符数
        int formed = 0; // 当前窗口中满足条件的独特字符数

        for(int right = 0; right < s.length(); right++){
            window.put(s.charAt(right), window.getOrDefault(s.charAt(right), 0) + 1);
            // 这一步判断formed非常精妙, 完美对应
            if(target.containsKey(s.charAt(right)) && window.get(s.charAt(right)).equals(target.get(s.charAt(right))) ) {
                formed++;
            }
            // 当formed = required时, 说明此时独特字符的1.种类 2.个数都以满足
            // 现在可以尝试移动左指针, 以便寻找下一个满足条件的窗口
            while(formed == required){
                // 记录当前窗口, 相当于Math.max, Math.min
                if(result[0] == -1 || result[0] > right - left + 1){
                    result[0] = right - left + 1;
                    result[1] = left;
                    result[2] = right;
                }
                // 删减移出左边界字符
                window.put(s.charAt(left), window.get(s.charAt(left)) -1 );
                
                // 一旦left指针所指的左边界字符为t中的字符, 且被删减后, formed-1
                if( target.containsKey(s.charAt(left)) && window.get(s.charAt(left)) < target.get(s.charAt(left) )){
                    formed--;
                }
                left++;
            }
        }
        return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);  // 正确截取子串, 注意左闭右开
        // return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);
        // 等价于
        // if (result[0] == -1) {
        //     return "";       // 情况1：没有找到有效子串时返回空字符串
        // } else {
        //     return s.substring(result[1], result[2] + 1); // 情况2：返回找到的最小窗口子串
        // }
    }
}
```

---

- return 条件语句 ? 结果1:结果2 
1) 例子: return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);// 正确截取子串, 注意左闭右开
- 等价于
2) if (result[0] == -1) {
-     return "";       // 情况1：没有找到有效子串时返回空字符串
- } else {
-     return s.substring(result[1], result[2] + 1); // 情况2：返回找到的最小窗口子串
- }

---
`python语法`
```python
class Solution(object):
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """
        # 特殊情况判断，当s或t为空，或者子字符串t比s多，直接return""
        if(len(s) == 0 or len(t) == 0 or len(t) > len(s)):
            return ""
        # 创建子字符串t的字典，统计t的(1)独特字符(2)独特字符对应的数量
        t_dict = {}
        for i in range(len(t)):
            # 不需要java的.charAt(), python可以把字符串当成字符数组操作，不更改字符串的情况下
            t_dict[t[i]] = t_dict.get(t[i], 0) + 1
        
        # 创建一个列表，以便记录最短字符串的长度，和left，right位置
        result = [-1, 0, 0]
        left = 0
        res_match = 0 # 创建res_match变量，计算s中满足的字符数量

        # 创建字符串s的字典, 滑动窗口核心元素(1)
        window_dict = {}
        for right in range(len(s)):
            # 不需要java的.charAt()，直接填充字典
            window_dict[s[right]] = window_dict.get(s[right], 0) + 1
            # 如果当前字符也存在t中，且此时窗口收集的该字符数量 = t中该字符数量，res_match+1
            if(s[right] in t_dict.keys() and t_dict[s[right]] == window_dict[s[right]]):
                res_match += 1
            # while判断临界值, 滑动窗口核心元素(2)
            while(res_match == len(t_dict)):
                # 保留最值，滑动窗口核心元素(3)
                if(result[0] == -1 or result[0] > (right - left + 1)):
                    result[0] = (right - left + 1)
                    result[1] = left
                    result[2] = right
                # 开始尝试新的窗口，左移left指针，并删减元素
                window_dict[s[left]] = window_dict.get(s[left]) - 1
                # 每次删减后，判断left指针所指的左边界字符为t中的字符, 且被删减后, formed-1
                if(s[left] in t_dict.keys() and t_dict[s[left]] > window_dict[s[left]]):
                    res_match -= 1
                left += 1
            
        # 返回结果
        if result[0] == -1:
            return ""
        else:
            return s[result[1] : result[2]+1]    #用切片代替java的substring
```
