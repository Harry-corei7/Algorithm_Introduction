`难度: 困难`

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 
示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

示例 2：

输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。

示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。

---

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public String minWindow(String s, String t) {
        if(s.length() == 0 || t.length() == 0 || t.length() > s.length()){
            return"";
        }
        // (1)创建储存t数组的HashMap
        Map<Character, Integer> target = new HashMap<>();
        // 统计t数组的 1.独特字母 2.独特字母对应的数量
        for(int i = 0; i < t.length(); i++){
            target.put(t.charAt(i), target.getOrDefault(t.charAt(i), 0) + 1);
        }

        // (2)创建储存s数组的HashMap
        Map<Character, Integer> window = new HashMap<>();

        // (3)创建数组result记录符合条件的最小length以及此时left, right位置
        int[] result = {-1, 0, 0};
        int left = 0;

        int required = target.size(); // 需要满足的独特字符数
        int formed = 0; // 当前窗口中满足条件的独特字符数

        for(int right = 0; right < s.length(); right++){
            window.put(s.charAt(right), window.getOrDefault(s.charAt(right), 0) + 1);
            // 这一步判断formed非常精妙, 完美对应
            if(target.containsKey(s.charAt(right)) && window.get(s.charAt(right)).equals(target.get(s.charAt(right))) ) {
                formed++;
            }
            // 当formed = required时, 说明此时独特字符的1.种类 2.个数都以满足
            // 现在可以尝试移动左指针, 以便寻找下一个满足条件的窗口
            while(formed == required){
                // 记录当前窗口, 相当于Math.max, Math.min
                if(result[0] == -1 || result[0] > right - left + 1){
                    result[0] = right - left + 1;
                    result[1] = left;
                    result[2] = right;
                }
                // 删减移出左边界字符
                window.put(s.charAt(left), window.get(s.charAt(left)) -1 );
                
                // 一旦left指针所指的左边界字符为t中的字符, 且被删减后, formed-1
                if( target.containsKey(s.charAt(left)) && window.get(s.charAt(left)) < target.get(s.charAt(left) )){
                    formed--;
                }
                left++;
            }
        }
        return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);  // 正确截取子串, 注意左闭右开
        // return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);
        // 等价于
        // if (result[0] == -1) {
        //     return "";       // 情况1：没有找到有效子串时返回空字符串
        // } else {
        //     return s.substring(result[1], result[2] + 1); // 情况2：返回找到的最小窗口子串
        // }
    }
}
```

---

- return 条件语句 ? 结果1:结果2 
1) 例子: return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);// 正确截取子串, 注意左闭右开
- 等价于
2) if (result[0] == -1) {
-     return "";       // 情况1：没有找到有效子串时返回空字符串
- } else {
-     return s.substring(result[1], result[2] + 1); // 情况2：返回找到的最小窗口子串
- }
