`难度: 中等`

**滑动窗口(可以看作双指针法的一种)**

`1) 核心元素: 左右指针, 窗口长度result`
  
`2) 核心机制: for循环遍历并移动right, 内套while判断(通过Math.min取得最小值)+移动左指针`

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0

---
`java语法`
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 滑动窗口(可以看作双指针法的一种)
        // (1) 核心元素: 左右指针, 窗口长度result
        // (2) 核心机制: for循环遍历并移动right, 内套while判断(通过Math.min取得最小值)+移动左指针, 
        int left = 0;
        int result = Integer.MAX_VALUE, sum = 0;
        for(int right = 0; right <= (nums.length-1); right++){ // 移动右指针,遍历数组,记录所有窗口
            sum += nums[right]; // sum增加右指针所指新元素

            while(sum >= target){ // 达到临界值
                result = Math.min(result, right - left + 1); // 比较新的窗口大小,取小值
                sum -= nums[left]; // 开始寻找下一个窗口, sum减少左指针所指旧元素
                left++; // 移动左指针
            }
        }
        if(result == Integer.MAX_VALUE){
            return 0;
        } else {
            return result;
        }
    }
}
```

---
`python语法`
```python
class Solution(object):
    def minSubArrayLen(self, target, nums):
        """
        :type target: int
        :type nums: List[int]
        :rtype: int
        """
        left = 0
        result = sys.maxsize
        win_sum = 0
        for i in range(0, len(nums)):
            win_sum += nums[i]

            while(win_sum >= target):
                result = min(i - left + 1, result)
                win_sum -= nums[left]
                left += 1
        
        if(result == sys.maxsize):
            return 0
        else:
            return result
```
