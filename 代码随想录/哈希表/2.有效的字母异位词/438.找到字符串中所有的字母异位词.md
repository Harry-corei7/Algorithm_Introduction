`难度: 中等`

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

1) 示例 1:

- 输入: s = "cbaebabacd", p = "abc"
- 输出: [0,6]
- 解释:
- 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
- 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

2) 示例 2:

- 输入: s = "abab", p = "ab"
- 输出: [0,1,2]
- 解释:
- 起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
- 起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
- 起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

---
`java语法`
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        // 建立ArrayList数组,便于储存符合条件的left指针
        ArrayList List = new ArrayList<>();
        // 建立指针与数组
        int left = 0;
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        // 首先遍历p,获得所有字母频率
        for(int i = 0; i < p.length(); i++){
            pCount[p.charAt(i) - 'a']++;
        }

        // 建立滑动窗口, 靠Arrays.equals(sCount, pCount)对比结果
        // Arrays.equals(sCount, pCount)返回True或False
        for(int right = 0; right < s.length(); right++){
            sCount[s.charAt(right) - 'a']++;
            if(right - left + 1 == p.length()){
                if(Arrays.equals(sCount, pCount)){
                    List.add(left);
                }
                sCount[s.charAt(left) - 'a']--;
                left++;
            }
        }
        return List;
    }
}
```
---
`python语法1, 与java语法逻辑完全相同`
```python
class Solution(object):
    def findAnagrams(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: List[int]
        """
        # (1)建立第一个字典p_count，记录p的元素信息和数量
        p_count = {}
        for i in range(len(p)):
            p_count[p[i]] = p_count.get(p[i], 0) + 1
        # 建立list，存储索引，建立left，建立滑动窗口
        list = []
        left = 0
        # 通过滑动窗口，遍历s，获取所有索引
        # (2)建立第二个字典s_count，记录s的在固定区间的元素信息和数量
        # 以便和p_count对比
        s_count = {}
        for right in range(len(s)):
            s_count[s[right]] = s_count.get(s[right], 0) + 1
            # 当窗口到达固定长度，检查p_count和s_count是否相同
            if((right - left + 1) == len(p)):
                if(p_count == s_count):
                    list.append(left)
                # 窗口左移，将left边缘的元素消去
                s_count[s[left]] = s_count.get(s[left], 0) - 1
                # 注意：当某个字符的计数减到0时，它仍然存在于字典中
                # 这里错过了，要记住彻底字典消去，用del
                if(s_count[s[left]] == 0):
                    del s_count[s[left]]
                left += 1
                
        return list
```
---
`python语法2, 没有直接对比两个哈希表，而是多一个for检查一个哈希表`

`容易超时`
```python
class Solution(object):
    def findAnagrams(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: List[int]
        """
        # 首先建立字典，记录p的元素信息和数量
        p_count = {}
        for i in range(len(p)):
            p_count[p[i]] = p_count.get(p[i], 0) + 1
        # 建立list，存储索引，建立left，建立滑动窗口
        list = []
        left = 0
        # 通过滑动窗口，遍历s，获取所有索引
        for right in range(len(s)):
            p_count[s[right]] = p_count.get(s[right], 0) - 1
            # 当窗口到达固定长度，检查p_count
            if((right - left + 1) == len(p)):
                valid = True
                # 如果在right - left + 1长度下，p_count元素都为0，则此[left, right]区间符合要求
                for i in range(len(p)):
                    if(p_count[p[i]] != 0):
                        valid = False
                if valid:
                    list.append(left)
                # 窗口左移
                p_count[s[left]] = p_count.get(s[left], 0) + 1
                left += 1
        return list
```
