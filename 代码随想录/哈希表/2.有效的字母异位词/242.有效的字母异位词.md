给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的**字母异位词**。

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false

---

1) 问题 1：「record[s.charAt(i) - 'a']++」是什么意思？
- 本质: 把字符串`s`中第`i`个字符`s.charAt(i)`映射到`record`数组中某个下标，然后将该位置的元素加 1。
- 为什么用 []++ : ++ 是自增操作，表示这个字符出现了一次, 最终作用是 统计每个字母出现的频率。
- 例如，如果当前 s.charAt(i) == 'c'，那么：
  - `record['c' - 'a']++ ⇨ record[2]++` 

2) 问题 2：「s.charAt(i) - 'a'」到底是什么？
- 本质: 这是一个`字符`到`数组下标`的映射方式。
- Java 中字符 `a` 到 `z` 在 ASCII 或 Unicode 编码中是 连续的整数（`a` = 97, `b` = 98, ..., `z` = 122）。
- `s.charAt(i) - 'a' ⇨ 把字符映射为 0~25 之间的整数`
- 字符: 'a'	'b'	'c'	...	'z' -> 值: 0	1	2	...	25

---
`java语法`
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        // 创建一个26位的数组
        int[] record = new int[26];

        // record[]数组自增自减操作
        // 1.如果当前 s.charAt(i) == 'c'，那么：
        // 2.record['c' - 'a']++ ⇨ record[2]++
        for(int i = 0; i < s.length(); i++){
            record[s.charAt(i) - 'a']++;
        }
        for(int i = 0; i < t.length(); i++){
            record[t.charAt(i) - 'a']--;
        }

        // 检查record数组的每一位元素是否清零
        for(int count : record){
            if(count != 0){
                return false;
            }
        }
        return true;
    }
```

---
`java语法`
```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] sCount = new int[26];
        int[] tCount = new int[26];

        for(int i = 0; i < s.length(); i++){
            sCount[s.charAt(i) - 'a']++;
        }
        for(int i = 0; i < t.length(); i++){
            tCount[t.charAt(i) - 'a']++;
        }
        // 练习使用Arrays.equals()方法
        return Arrays.equals(sCount, tCount);
    }
}
```

---
`python语法`
```python
class Solution(object):
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        # 很明显，如果s和t长度不等，直接返回False
        if(len(s) != len(t)):
            return False
        count = {}
        # 利用字典，其实相当于hashmap
        for i in range(len(s)):
            count[s[i]] = count.get(s[i], 0) + 1
        for i in range(len(t)):
            count[t[i]] = count.get(t[i], 0) - 1
        # 因为已经判断过长度了，所以这里判断t或者s的元素都可以
        # 不存在t是s的子字符串，导致t对应的元素都为0的情况(反过来也一样)
        for i in range(len(t)):
            if(count[t[i]] != 0):
                return False
        return True
```
`关于get()的操作`
- count.get(s[i], 0) 只是获取值，不会添加key
- 真正添加key的是 count[s[i]] = ... 这个赋值操作
