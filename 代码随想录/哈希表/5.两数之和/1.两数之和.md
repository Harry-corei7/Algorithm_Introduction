给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

示例 1：
- 输入：nums = [2,7,11,15], target = 9
- 输出：[0,1]
- 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：
- 输入：nums = [3,2,4], target = 6
- 输出：[1,2]

示例 3：
- 输入：nums = [3,3], target = 6
- 输出：[0,1]

---

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        HashMap<Integer, Integer> map = new HashMap<>();

        // (1) 先判断特殊情况
        if(nums.length == 0 || nums == null){
            return result;
        }
        // (2) 遍历数组
        for(int i = 0; i < nums.length; i++){
            
            int temp = target- nums[i];
            if(map.containsKey(temp)){
                result[0] = i;
                result[1] = map.get(temp);
                break;
            }
            // 必须前判断，后插入新元素，对map进行赋值
            // 这里可能比较反逻辑，因为num[0]不用判断就可以插入map
            // 主要是先插入元素，后判断，如果6 = 3+3，就会有错误
            map.put(nums[i], i);
        }
        return result;
    }
}
```
`python语法`
```python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        result = []
        count = {}
        # 对特殊情况进行判断:
        if(len(nums) < 2 or target == None):
            return result
        # (1) 方法1: 一上来容易想到for循环*2，但是有更好的解法
        # (2) 方法2: for循环*1，每次遍历一个元素，将其存在HasMap里，
        # 后续遍历新元素，HasMap查找另一个加数
        for i in range(len(nums)):
            temp = target - nums[i]
            # 先判断
            if(temp in count.keys()):
                result.append(count.get(temp))
                result.append(i)
                return result
            # 后将新元素填充在map里
            # 键: 元素值
            # 值: 元素index
            count[nums[i]] = i
```
