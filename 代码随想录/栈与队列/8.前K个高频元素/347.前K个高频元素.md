`难度: 中等`

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

1) 示例 1:
- 输入: nums = [1,1,1,2,2,3], k = 2
- 输出: [1,2]

2) 示例 2:
- 输入: nums = [1], k = 1
- 输出: [1]

---

`大顶堆-小顶堆`

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // (1)建立hash表，统计每一种数字的频率
        // Key是每一种数字, Value是每一种数字出现的频率
        Map<Integer, Integer> freq = new HashMap<>();
        for(int num : nums){
            freq.put(num, freq.getOrDefault(num,0) +1);
        }

        // (2)建立优先队列PriorityQueue, 大顶堆lamda公式降序
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[1] - a[1]);

        // (3)Map.Entry = freq.entrySet()遍历HashMap, 输入大顶堆
        for(Map.Entry<Integer, Integer> entry : freq.entrySet()){
            pq.offer(new int[]{entry.getKey(), entry.getValue()});
            // pq队列的每一个元素是一个包含两个数字的一维数组
        }

        // (4)取频率为前k的数字
        int[] result = new int[k];
        for(int i = 0; i < k; i++){
            int[] top = pq.poll();
            result[i] = top[0];
        }

        return result;
    }
}
```
