`难度：中等`

- 给定一个已排序的链表的头`head`， **删除原始链表中所有重复数字的节点，只留下不同的数字**。
- 返回`已排序的链表`。

- 示例 1：
  - 输入：head = [1,2,3,3,4,4,5]
  - 输出：[1,2,5]

<img width="782" height="222" alt="image" src="https://github.com/user-attachments/assets/a5232955-e6ef-43bc-b691-c39fe95e85df" />

- 示例 2：
  - 输入：head = [1,1,1,2,3]
  - 输出：[2,3]

<img width="542" height="222" alt="image" src="https://github.com/user-attachments/assets/dd76e924-8d47-4a13-94e0-a246ee7bc8c9" />

---
`python语法`
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def deleteDuplicates(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy_head = ListNode(-1)
        dummy_head.next = head
        pre = dummy_head
        cur = head
        # 特殊情况
        if(head == None): return dummy_head.next
        while(cur.next != None):
            if(cur.val == cur.next.val): # 如果出现相同情况
                while(cur.next != None and cur.val == cur.next.val):
                    cur = cur.next # 将cur移动到最后一个相同值的节点
                cur = cur.next # 将cur移动到不是相同值的下一个节点
                pre.next = cur # 删除相同值
                if(cur == None): break # 如果cur已经是None了，直接break
            else:
                pre = cur
                cur = cur.next
        
        return dummy_head.next
```
