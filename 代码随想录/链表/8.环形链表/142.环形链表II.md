`难度: 中等`

1) 给定一个链表的头节点`head`，返回链表开始入环的第一个节点。 如果链表无环，则返回`null`。
2) 如果链表中有某个节点，可以通过连续跟踪`next`指针再次到达，则链表中存在环。
3) 为了表示给定链表中的环，评测系统内部使用整数`pos`来表示链表尾连接到链表中的位置（索引从 0 开始）。
4) 如果`pos`是 -1，则在该链表中没有环。注意:`pos`不作为参数进行传递，仅仅是为了标识链表的实际情况。

- 不允许修改 链表。

---

---

`我的简单粗暴方法: 双指针法-简陋版`

`java语法`
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 创建虚拟头节点, 接在原来的ListNode上
        ListNode dumyhead = new ListNode(-1);
        dumyhead.next = head;
        // 创建快慢针
        ListNode fastCur = dumyhead;
        ListNode slowCur = dumyhead;
        // 创建两种步数
        int gap = 0;
        int realgap = 0;

        while(fastCur != null){
            fastCur = fastCur.next;
            gap++; // 记录快指针距离dumyhead的步数
            while(slowCur != fastCur){
                slowCur = slowCur.next;
                realgap++; // 记录慢指针从dumyhead到快指针的位置的步数
            }
            if(realgap != gap){
                return slowCur; // 返回开始入环的第一个节点
            }
            slowCur = dumyhead;
            realgap = 0;
        }
        return null;
    }
}
```
`python语法`
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 设置虚拟头节点
        dumy_head = ListNode(-1)
        dumy_head.next = head
        # 设置快慢双指针
        slow_cur = dumy_head
        fast_cur = dumy_head
        # 计算两种步数
        gap = 0
        real_gap = 0
        # 循环遍历以确定有没有环，入环点在哪
        while(fast_cur != None):
            fast_cur = fast_cur.next
            # 记录fast_cur步数
            gap += 1
            # 记录fast_cur距离虚拟头节点的真实距离
            while(slow_cur != fast_cur):
                slow_cur = slow_cur.next
                real_gap += 1
            if(real_gap != gap): # 确认有环，且找到入环点
                return slow_cur
            slow_cur = dumy_head # 慢针回归原位，准备下轮遍历的测量
            real_gap = 0 # 刷新real_gap
        # 最终fast_cur==None，循环结束，说明没环
        return None
```
