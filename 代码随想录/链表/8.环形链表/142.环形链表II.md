`难度: 中等`

1) 给定一个链表的头节点`head`，返回链表开始入环的第一个节点。 如果链表无环，则返回`null`。
2) 如果链表中有某个节点，可以通过连续跟踪`next`指针再次到达，则链表中存在环。
3) 为了表示给定链表中的环，评测系统内部使用整数`pos`来表示链表尾连接到链表中的位置（索引从 0 开始）。
4) 如果`pos`是 -1，则在该链表中没有环。注意:`pos`不作为参数进行传递，仅仅是为了标识链表的实际情况。

- 不允许修改 链表。

---

---

`我的简单粗暴方法: 双指针法-简陋版`

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 创建虚拟头节点, 接在原来的ListNode上
        ListNode dumyhead = new ListNode(-1);
        dumyhead.next = head;
        // 创建快慢针
        ListNode fastCur = dumyhead;
        ListNode slowCur = dumyhead;
        // 创建两种步数
        int gap = 0;
        int realgap = 0;

        while(fastCur != null){
            fastCur = fastCur.next;
            gap++; // 记录快指针距离dumyhead的步数
            while(slowCur != fastCur){
                slowCur = slowCur.next;
                realgap++; // 记录慢指针从dumyhead到快指针的位置的步数
            }
            if(realgap != gap){
                return slowCur; // 返回开始入环的第一个节点
            }
            slowCur = dumyhead;
            realgap = 0;
        }
        return null;
    }
}
```
