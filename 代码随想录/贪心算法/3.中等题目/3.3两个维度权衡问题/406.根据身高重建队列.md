`难度：中等`

- 假设有打乱顺序的一群人站成一个队列，数组`people`表示队列中一些人的属性（不一定按顺序）。
- 每个`people[i] = [hi, ki]`表示第`i`个人的身高为`hi`，前面**正好**有`ki`个身高大于或等于`hi`的人。

- 请你重新构造并返回输入数组`people`所表示的队列。
- 返回的队列应该格式化为数组`queue`，其中`queue[j] = [hj, kj]`是队列中第`j`个人的属性（queue[0] 是排在队列前面的人）。

---
### 贪心算法讲解

- **维度(1) 身高hj**

- 如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。
- 那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。
- **此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！**
- **按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。**
- 举例说明

<img width="800" height="500" alt="image" src="https://github.com/user-attachments/assets/7b44e276-a04e-4f8c-a5ee-15bf19184782" />

- **维度(2) 前几个人身高>= 自己kj**

- `个人理解`：利用了kj的特性，在维度1排序完毕的基础上，再根据kj来insert动态数组，即可得到下面结果
- 排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]
- 插入的过程：
  - 插入[7,0]：[[7,0]]
  - 插入[7,1]：[[7,0],[7,1]]
  - 插入[6,1]：[[7,0],[6,1],[7,1]]
  - 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
  - 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
  - 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

---
`python语法：贪心算法`
```python
class Solution(object):
    def reconstructQueue(self, people):
        """
        :type people: List[List[int]]
        :rtype: List[List[int]]
        """
        # 维度1: 
        # sort规则: 对people列表的每一个元素x
        # 首先，按x[0] "h身高"降序
        # 其次，按x[1] "k"升序
        people.sort(key = lambda x:(-x[0], x[1])) # lambda在多元排序规则下返回的是元组

        # 将元组转化为数组
        # 维度2: 单纯考虑p[1]
        # people已经排序过了：同一高度时k值小的排前面。
        que = []
        for p in people:
            que.insert(p[1], p)
        
        return que
```
