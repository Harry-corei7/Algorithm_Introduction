`难度：困难`

- `n`个孩子站成一排。给你一个整数数组`ratings`表示每个孩子的评分。
- 你需要按照以下要求，给这些孩子分发糖果：
  - 每个孩子至少分配到 1 个糖果。
  - 相邻两个孩子中，评分更高的那个会获得更多的糖果。
  - 请你给每个孩子分发糖果，计算并返回需要准备的`最少糖果数目`。

- 示例 1：
  - 输入：ratings = [1,0,2]
  - 输出：5
  - 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

- 示例 2：
  - 输入：ratings = [1,2,2]
  - 输出：4
  - 解释：
    - 你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
    - 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
---
### 贪心算法思路

- 这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，**如果两边一起考虑一定会顾此失彼**。

- (1) 先确定右边评分大于左边的情况（也就是从前向后遍历）
- 思路：
  - 只要右边评分比左边大，右边的孩子就多一个糖果。
  - 如果右边评分等于甚至小于左边，右边的孩子就只得到一个糖果`确保总的糖果数目最小`。
```python
for i in range(1, len(ratings)):
    if(ratings[i] > ratings[i-1]):
        candyVec.append(candyVec[i-1] + 1)
    else:
        candyVec.append(1)
```
- **注意：这不是结束，因为题目要求是“相邻的孩子中，分数高的获得更多糖果”**
- 我们只确保了`一个孩子评分高，获得糖果比他左边孩子的糖果多`，**但没有考虑这个孩子的右边孩子分数高低的情况**
- 听起来很拗口，举一个例子：

<img width="720" height="270" alt="image" src="https://github.com/user-attachments/assets/b379f38d-9dea-412c-bec5-356e2da9e775" />

- 如图所示：只考虑右边>左边的情况下，下标4，5，6号的孩子的糖果数目只得1，不符合题目要求
- (2) 在(1)的基础上，再确定左边评分大于右边的情况(从后往前遍历)
- 思路：
  - 在(1)的值的基础上，从后往前遍历，糖果数目取max
  - 这样确保了`一个孩子评分高，获得糖果比他右边孩子的糖果多`
```python
for i in range(len(ratings)-2, -1, -1):
    if(ratings[i] > ratings[i+1]):
        candyVec[i] = max(candyVec[i], candyVec[i+1]+1) # 在"原值"和"比右边孩子糖果数目+1"取最大值
```

---
`python语法：贪心算法`
```python
class Solution(object):
    def candy(self, ratings):
        """
        :type ratings: List[int]
        :rtype: int
        """
        candyVec = []
        candyVec.append(1)
        # 从左向右遍历
        for i in range(1, len(ratings)):
            if(ratings[i] > ratings[i-1]):
                candyVec.append(candyVec[i-1] + 1)
            else:
                candyVec.append(1)
        # 从右向左遍历
        for j in range(len(ratings)-2, -1, -1):
            if(ratings[j] > ratings[j+1]):
                candyVec[j] = max(candyVec[j], candyVec[j+1]+1)
        
        return sum(candyVec)
```
