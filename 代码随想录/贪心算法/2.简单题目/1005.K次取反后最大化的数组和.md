- 给你一个整数数组`nums`和一个整数`k`，按以下方法修改该数组：
- 选择某个下标`i`并将`nums[i]`替换为`-nums[i]`。
- 重复这个过程恰好`k`次。可以多次选择同一个下标`i`。
- 要求以这种方式修改数组，返回数组**可能的最大和**。

- 示例 1：
  - 输入：nums = [4,2,3], k = 1
  - 输出：5
  - 解释：选择下标 1 ，nums 变为 [4,-2,3] 。

- 示例 2：
  - 输入：nums = [3,-1,0,2], k = 3
  - 输出：6
  - 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。

- 示例 3：
  - 输入：nums = [2,-3,-1,5,-4], k = 2
  - 输出：13
  - 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。

---
- 第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和
`python语法：贪心算法`
```python
class Solution(object):
    def largestSumAfterKNegations(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        # 第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
        nums_sorted = sorted(nums, key=abs, reverse=True)
        result = 0

        for i in range(0, len(nums_sorted)):
            if(k > 0 and nums_sorted[i] < 0): #第二步：从前向后遍历，遇到负数将其变为正数，同时K--
                nums_sorted[i] = nums_sorted[i]*(-1)
                k -= 1
            result += (nums_sorted[i])
                
        
        if(k > 0): # 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
            k = (k % 2)
            for i in range(0, k):
                result += nums_sorted[-1]*(-1)*2
        return result
```
