- 在柠檬水摊上，每一杯柠檬水的售价为`5 美元`。
- 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
- 每位顾客只买一杯柠檬水，然后向你付`5 美元`、`10 美元`或`20 美元`。
- 你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付`5 美元`。

- 示例 1：
  - 输入：[5,5,5,10,20]
  - 输出：true
  - 解释：
    - 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
    - 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
    - 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
    - 由于所有客户都得到了正确的找零，所以我们输出 true。

- 示例 2：
  - 输入：[5,5,10]
  - 输出：true

- 示例 3：
  - 输入：[10,10]
  - 输出：false

- 示例 4：
  - 输入：[5,5,10,10,20]
  - 输出：false
  - 解释：
    - 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
    - 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
    - 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
    - 由于不是每位顾客都得到了正确的找零，所以答案是 false。

---
- 此时大家就发现 情况一(付5)，情况二(付10)，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三(付20)。
- 而情况三(付20)逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。
- 账单是20的情况，为什么要优先消耗一个10和一个5呢？
- **因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！**
---
`python语法：个人理解版`
```python
class Solution(object):
    def lemonadeChange(self, bills):
        """
        :type bills: List[int]
        :rtype: bool
        """
        money_5 = 0
        money_10 = 0
        money_20 = 0
        for i in range(len(bills)):
            if(bills[i] == 5): # 如果客户支付5元，无需找零
                money_5 += 1
            if(bills[i] == 10): # 如果客户支付10元，一种找零方式
                if(money_5 >= 1):
                    money_5 -= 1
                    money_10 += 1
                else:
                    return False
            if(bills[i] == 20): # 如果客户支付20元，两种找零方式
                if(money_5 >= 1 and money_10 >= 1):
                    money_5 -= 1
                    money_10 -= 1
                    money_20 += 1
                elif(money_5 >= 3):
                    money_5 -= 3
                    money_20 += 1
                else:
                    return False
        return True
```
