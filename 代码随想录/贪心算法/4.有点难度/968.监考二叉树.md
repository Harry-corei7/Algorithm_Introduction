<img width="139" height="312" alt="image" src="https://github.com/user-attachments/assets/0a73045b-b924-4b48-bdd2-2deb6b49bd22" />`难度：困难`

- 给定一个二叉树，我们在树的节点上安装摄像头。
- 节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象**。
- 计算监控树的所有节点所需的最小摄像头数量。

- 示例 1：
  - 输入：[0,0,null,0,0]
  - 输出：1
  - 解释：如图所示，一台摄像头足以监控所有节点。

<img width="138" height="163" alt="image" src="https://github.com/user-attachments/assets/2b25917a-b105-479e-803d-ef584bc2ba9c" />

- 示例 2：
  - 输入：[0,0,null,0,null,0,null,null,0]
  - 输出：2
  - 解释：需要至少两个摄像头来监视树的所有节点。 如图所示，显示了摄像头放置的有效位置之一。

<img width="139" height="312" alt="image" src="https://github.com/user-attachments/assets/2cc49d54-17f3-4c92-ac21-3566dc633cf3" />

---
> 贪心算法思路

- 从题目中示例，其实可以得到启发，**我们发现题目示例中的摄像头都没有放在叶子节点上！**
  - 这是很重要的一个线索，摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。
  - 所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。
  - 为什么不从头结点开始看起呢，为啥要从叶子节点看呢？因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。

- **所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

- 此时这道题目还有两个难点：
  1) 二叉树的遍历
  2) 如何隔两个节点放一个摄像头

### 二叉树的遍历

- 在二叉树中如何从低向上推导呢？
- 可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。
- 后序遍历代码如下：
```python
self.traversal(cur):

    # 空节点，该节点有覆盖
    if (终止条件) return ;

    int left = traversal(cur.left)     # 左
    int right = traversal(cur.right)   # 右

    逻辑处理模块(根据left, right的值进行处理) # 中
    return
```

### 如何隔两个节点放一个摄像头

- 来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：
- 有如下三种：
  - 该节点无覆盖
  - 本节点有摄像头
  - 本节点有覆盖
- 我们分别有三个数字来表示：
  - 0：该节点无覆盖
  - 1：本节点有摄像头
  - 2：本节点有覆盖

- **因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？**
  - 那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，
  - 空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。
  - 所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了
- 代码如下：
```python
if(cur == NULL): return 2
```

1) 情况1：左右节点都有覆盖
- 左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。

<img width="230" height="190" alt="image" src="https://github.com/user-attachments/assets/e69e00bd-75a2-495e-adb9-f8139d1bb9e8" />

- 代码如下：
```python
if(left == 2 and right == 2): return 0
```

2) 情况2：左右节点至少有一个无覆盖的情况
- 如果是以下情况，则中间节点（父节点）应该放摄像头：
  - left == 0 && right == 0 左右节点无覆盖
  - left == 1 && right == 0 左节点有摄像头，右节点无覆盖
  - left == 0 && right == 1 左节点有无覆盖，右节点摄像头
  - left == 0 && right == 2 左节点无覆盖，右节点覆盖
  - left == 2 && right == 0 左节点覆盖，右节点无覆盖
- 这个不难理解，毕竟有一个孩子没有覆盖，父节点就应该放摄像头。
- 此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。
- 代码如下：
```python
if (left == 0 or right == 0):
    result += 1
    return 1
```

3) 情况3：左右节点至少有一个有摄像头
- 如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）
  - left == 1 && right == 2 左节点有摄像头，右节点有覆盖
  - left == 2 && right == 1 左节点有覆盖，右节点有摄像头
  - left == 1 && right == 1 左右节点都有摄像头
- 代码如下：
```python
if(left == 1 or right == 1): return 2
```
- **从这个代码中，可以看出，如果left == 1, right == 0 怎么办？其实这种条件在情况2中已经判断过了**，如图：

<img width="390" height="310" alt="image" src="https://github.com/user-attachments/assets/06121657-3bc3-482c-ac78-d381e81c72de" />

- 这种情况也是大多数同学容易迷惑的情况。

4) 情况4：头结点没有覆盖
- 以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，如图：

<img width="500" height="400" alt="image" src="https://github.com/user-attachments/assets/53035236-2182-487a-be9c-cbae6475e7fa" />

---
`python语法：贪心算法`
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def traversal(self, cur, result):
        # 空节点，默认该节点有覆盖
        # 默认空节点有覆盖，则叶子节点得父节点就必须要安摄像头
        if(cur == None): return 2

        # 0：该节点无覆盖
        # 1：本节点有摄像头
        # 2：本节点有覆盖
        left = self.traversal(cur.left, result)
        right = self.traversal(cur.right, result)

        # 情况1
        # 左右节点都有覆盖
        if(left == 2 and right == 2): return 0

        # 情况2
        # left == 0 && right == 0 左右节点无覆盖
        # left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        # left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        # left == 0 && right == 2 左节点无覆盖，右节点覆盖
        # left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if(left == 0 or right == 0):
            result[0] += 1
            return 1

        # 情况3
        # left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        # left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        # left == 1 && right == 1 左右节点都有摄像头
        # 其他情况前段代码均已覆盖
        if(left == 1 or right == 1): return 2

        # 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        # 这个 return -1 逻辑不会走到这里。
        return -1


    def minCameraCover(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        # 定义递归函数
        result = [0]  # 用于记录摄像头的安装数量
        if(self.traversal(root, result) == 0): # 最后给头节点按摄像头
            result[0] += 1

        return result[0]
```
