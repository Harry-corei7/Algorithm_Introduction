`难度：中等`

- 给定一个`非负整数数组`，你最初位于数组的`第一个位置`。
- 数组中的每个元素代表你在`该位置`可以跳跃的`最大长度`。
- 你的目标是使用`最少的跳跃次数`到达`数组的最后一个位置`。

- 示例:
  - 输入: [2,3,1,1,4]
  - 输出: 2
  - 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳  1  步，然后跳  3  步到达数组的最后一个位置。
---
### 关于递归传递变量的补充

**在Python的参数传递机制中**

1) `整数是不可变对象`，参数传递是按对象引用传递。
```python
def Jump(self, nums, i, step):
    ...
    step += 1  # 这行代码创建了一个新的整数对象
    self.Jump(nums, max_index, step)  # 传递这个新对象的引用

def jump(self, nums):
    step = 0
    self.Jump(nums, 0, step)
    return step # 这里返回的step是0，因为每次"更改step的值"，并没有更改这个地址的step，只是在新地址建立了step并赋值
```

2) `数组，字典是可变对象`，可以通过递归函数不断修改

3) `可以直接利用Python的类的属性变量`，相当于全局变量
```python
class Solution(object):
    def __init__(self):
        self.step= 0
        
    def Jump(self, nums, i, step):
        ...
    def jump(self, nums):
        ...
```

---
`python语法：贪心算法`
```python
class Solution(object):
    def Jump(self, nums, i, step):
        cover = nums[i]
        if(i+cover >= len(nums)-1): 
            step += 1
            return step
        
        max_cover = i+cover
        max_index = i

        for j in range(i, i+cover+1):
            if(j+nums[j] > max_cover):
                max_cover = j+nums[j]
                max_index = j
        
        # 如果遍历完cover，发现自己最远只能达到i+cover的范围，则表示结果止步于此
        if(max_cover == i+cover): return False

        # step+1表示跳跃到maxindex
        step += 1
        step = self.Jump(nums, max_index, step)
        return step


    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if(len(nums) <= 1): return 0
        step = self.Jump(nums, 0, 0)
        return step
```
