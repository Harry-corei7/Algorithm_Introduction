`难度：中等`

- 有一些球形气球贴在一堵用`XY`平面表示的墙面上。
- 墙面上的气球记录在整数数组`points`，其中`points[i] = [xstart, xend]`表示水平直径在`xstart`和`xend`之间的气球。
- 你不知道(也不用知道)气球的确切`y`坐标。

- 一支弓箭可以沿着`x`轴从不同点`完全垂直`地射出。
- 在坐标`x`处射出一支箭，若有一个气球的直径的开始和结束坐标为`xstart，xend`，且满足`xstart ≤ x ≤ xend`，则该气球会被`引爆`。
- 可以射出的弓箭的数量`没有限制`。
- 弓箭一旦被射出之后，可以无限地前进。

- 给你一个数组`points`，返回引爆所有气球所必须射出的`最小`弓箭数。

- 示例 1：
  - 输入：points = [[10,16],[2,8],[1,6],[7,12]]
  - 输出：2
  - 解释：气球可以用2支箭来爆破:
    - 在x = 6处射出箭，击破气球[2,8]和[1,6]。
    - 在x = 11处发射箭，击破气球[10,16]和[7,12]。

- 示例 2：
  - 输入：points = [[1,2],[3,4],[5,6],[7,8]]
  - 输出：4
  - 解释：每个气球需要射出一支箭，总共需要4支箭。

- 示例 3：
  - 输入：points = [[1,2],[2,3],[3,4],[4,5]]
  - 输出：2
  - 解释：气球可以用2支箭来爆破:
    - 在x = 2处发射箭，击破气球[1,2]和[2,3]。
    - 在x = 4处射出箭，击破气球[3,4]和[4,5]。
---
> 贪心思路

- 直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？
- 尝试一下举反例，发现没有这种情况。

- **为了让气球尽可能的重叠，需要对数组进行排序。**
- 那么按照气球起始位置排序，还是按照气球终止位置排序呢？
- 其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。

- **如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭。**

<img width="800" height="500" alt="image" src="https://github.com/user-attachments/assets/ecbd2c10-9ed6-4c69-a5a1-227fe291459e" />

---
`python语法：贪心算法`
```python
class Solution(object):
    def findMinArrowShots(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        if(len(points) == 0): return 0
        # 对气球(按左边界"升序")进行排序
        points.sort(key = lambda x:x[0])
        # 记录箭的数量
        bow_count = 1
        # 右侧阈值，初始化为第一个气球右边界
        cur_min_right = points[0][1]

        for i in range(1, len(points)):
            if(points[i][0] > cur_min_right):
                bow_count += 1
                cur_min_right = points[i][1]
            else:
                # continue是错误，而是对比"当前新气球的右侧"pk"原有的右侧阈值"
                cur_min_right = min(cur_min_right, points[i][1])
        
        return bow_count
```
