`难度：中等`

- 给你一个`非负整数数组nums`，你最初位于数组的`第一个下标`。
- 数组中的每个元素代表你在该位置可以跳跃的最大长度。
- 判断你是否能够到达最后一个下标，如果可以，返回`true`；否则，返回`false`。

- 示例 1：
  - 输入：nums = [2,3,1,1,4]
  - 输出：true
  - 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
- 示例 2：
  - 输入：nums = [3,2,1,0,4]
  - 输出：false
  - 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

---
`python语法：贪心算法`
```python
class Solution(object):
    def Jump(self, nums, i):
        cover = nums[i]
        if(i+cover >= len(nums)-1): return True # 如果已经可以达到终点了，直接返回True
        
        # 记录目前index可以达到的最远范围
        max_step = i+cover
        max_step_index = i
        # 遍历范围内的所有index，检查是否有范围更大的index(作为下一步的起点)
        for j in range(i+1, i+cover+1):
            if(j+nums[j] > max_step):
                max_step = j+nums[j]
                max_step_index = j

        new_i = max_step_index
        if(new_i == i): return False # 范围内没找到可以进一步扩大范围的index，说明止步于此

        ans = self.Jump(nums, new_i)
        return ans
        
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        if(len(nums) == 1): return True
        return self.Jump(nums, 0)
```
