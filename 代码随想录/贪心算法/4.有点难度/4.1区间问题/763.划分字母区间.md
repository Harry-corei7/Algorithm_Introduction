`难度：中等`

- 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，`同一字母最多出现在一个片段中`。
- 例如，字符串 "ababcc" 能够被分为`["abab", "cc"]`，但类似`["aba", "bcc"]`或`["ab", "ab", "cc"]`的划分是非法的。
- 注意，划分结果需要满足：
  - 将所有划分结果按顺序连接，得到的字符串仍然是`s`。(同一种字母最多出现在一个片段中)
- 返回一个表示每个字符串片段的长度的列表。

- 示例 1：
  - 输入：s = "ababcbacadefegdehijhklij"
  - 输出：[9,7,8]
  - 解释：
    - 划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
    -  每个字母最多出现在一个片段中。
    - 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
示例 2：
  - 输入：s = "eccbbbbdec"
  - 输出：[10]
---
`python语法：贪心算法(个人理解版)`
```python
class Solution(object):
    def partitionLabels(self, s):
        """
        :type s: str
        :rtype: List[int]
        """
        # 创建word_dict字典储存所有的字母出现的第一个位置和最后一个位置
        word_dict = {}
        
        for index, word in enumerate(s):
            if(word not in word_dict):
                word_dict[word] = [index, index]
            else:
                word_dict[word][1] = index
        
        # 将所有字母的[起始位置, 终止位置]储存在一个数组并按x[0]"起始位置"排序
        que = []
        for i in word_dict.values():
            que.append(i)
        que.sort(key=lambda x:x[0])

        # 设置相关变量，求结果
        result = []
        cur_left = 0
        cur_right = que[0][1]
        for i in range(1, len(que)):
            # 核心：贪心算法逻辑
            # (1) 将每一个字母[起位置，终位置]看成一个序列
            # (2) 老规矩，先按x[起始位置]排序
            # (3) 若序列之间有重合，"表示这两个字母必被分割在一个字符串里"，更新cur_right右边界
            # (4) 若序列不重合，则找到一个切割点，result收集结果，并更新cur_left，cur_right
            # (5) 特殊情况：若cur_right已经触及len(s)-1，后面字母不需要遍历(都在这个序列里)，直接result收集结果+break
                # 否则，重复收集
            if(que[i][0] < cur_right):
                cur_right = max(cur_right, que[i][1])
            else:
                length = cur_right - cur_left + 1
                result.append(length)
                cur_left = que[i][0]
                cur_right = que[i][1]
            # 如果cur_right已经到底，不用继续遍历了，直接取结果并break
            if(cur_right == len(s)-1):
                result.append(cur_right-cur_left+1)
                break
        return result
```
