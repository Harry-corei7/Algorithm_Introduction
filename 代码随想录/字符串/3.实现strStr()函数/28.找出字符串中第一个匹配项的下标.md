给你两个字符串`haystack`和`needle`，

请你在`haystack`字符串中找出`needle`字符串的第一个匹配项的下标（下标从`0`开始）。

如果 needle 不是 haystack 的一部分，则返回  -1 。

1) 示例 1：
- 输入：haystack = "sadbutsad", needle = "sad"
- 输出：0
- 解释："sad" 在下标 0 和 6 处匹配。
- 第一个匹配项的下标是 0 ，所以返回 0 。
  
2) 示例 2：
- 输入：haystack = "leetcode", needle = "leeto"
- 输出：-1
- 解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。

---

`KMP算法`

- 前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串;
- 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串;

`KMP(1): 主函数`

```java
Class Solution{
    public int strStr(String haystack, String needle){
        // 创建next数组, 并利用getNext()函数对其进行填充
        int [] next = int[needle.length()];
        getNext(next, needle);
        // 主函数部分
        int j = 0;
        if(haystack.length() == 0){
            return -1;
        }
        for(int i = 0; i < haystack.length(); i++){
            while(j > 0 && haystack.charAt(i) != needle.charAt(j)){
                j = next[j-1];
            }
            if(haystack.charAt(i) == needle.charAt(j)){
                j++;
            }
            if(j == needle.length()){
                return i - needle.length() + 1;
            }
        }
        return -1;
    }
    // 下面为getNext函数
    // ........
}
```

`KMP(2): getNext函数`

```java
    private void getNext(int[] next, String s) {
        // 核心思想: 寻找最长相等的前缀和后缀
        // (1) 后缀: j所指的字符与其左边相连的前面字符组成的(可调整,要找到最长的)
        // (2) 前缀: 0所指的字符与其右边相连的后面字符组成的
        // (3) 前后缀相等的长度, 就是next数组里面的元素, 也是可跳过的步数
        // (3.1) 是因为前后缀相等, 所以可以跳过
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(j) != s.charAt(i)){
                j = next[j - 1];
            }
            if (s.charAt(j) == s.charAt(i)){
                j++;
            }
            next[i] = j; 
        }
    }
```

---

`老爸的.equals()方法`

1) 用`.substring(left, right)左开右闭`创建字符串变量
2) 用`.equals()`对比字符串内容

```java
class Solution {
    public int strStr(String haystack, String needle) {
        for(int i = 0; i < haystack.length(); i++){
            if(haystack.charAt(i) == needle.charAt(0)){
                int index = i;
                if(index + needle.length() > haystack.length()){
                    break;
                }

                String s = haystack.substring(index, index+needle.length());

                if(s.equals(needle)){
                    return index;
                }
                else{
                    continue;
                }
            }
        }
        return -1;
    }    
}
```

---

`我的穷举法`

```java
class Solution {
    public int strStr(String haystack, String needle) {
        for(int i = 0; i < haystack.length();  i++){
            if(haystack.charAt(i) == needle.charAt(0)){
                int index = i;
                int m = 0;
                for(int j = 0; j < needle.length(); j++){
                    // 特殊情况判断, 防止index溢出
                    if(i+j >= haystack.length()){
                        break;
                    }
                    // 在index的基础上, 向后逐个对比needle.length()长度的字符
                    else if(haystack.charAt(i+j) == needle.charAt(j)){
                        m++;
                        if(m == needle.length()){
                            return index;
                        }
                        continue;
                    }
                    // 如果有不符合, 直接跳出循环, 找下一个index
                    else{
                        break;
                    }

                }
            }
        }
        return -1;
    }    
}
```
