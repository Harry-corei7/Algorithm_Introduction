`难度：困难`

- 给出`二叉搜索树`的根节点，该树的节点值各不相同。
- 请你将其转换为累加树（Greater Sum Tree），使每个节点`node`的新值等于原树中大于或等于`node.val`的值之和。

- **提醒一下**，二叉搜索树满足下列约束条件：
  - 节点的左子树仅包含键`小于`节点键的节点。
  - 节点的右子树仅包含键`大于`节点键的节点。
  - 左右子树也必须是二叉搜索树。

- 示例 1：
- 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
- 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
<img width="775" height="529" alt="image" src="https://github.com/user-attachments/assets/ac957461-240a-40c8-9d9a-1546250316cb" />

- 示例 2：
- 输入：root = [0,null,1]
- 输出：[1,null,1]

- 示例 3：
- 输入：root = [1,0,2]
- 输出：[3,3,2]

- 示例 4：
- 输入：root = [3,2,4,1]
- 输出：[7,9,4,10]

---
`python语法：迭代法(中序迭代遍历取反+pre指针)`
```python
class Solution(object):
    def convertBST(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """
        if(root == None): return None
        cur = root
        pre = 0 # 记录前一个节点的值 
        stack = []
        while(cur != None or len(stack) != 0):
            # 左中右 ——> 右中左
            if(cur != None):
                stack.append(cur)
                cur = cur.right # 右，右到底
            else:
                cur = stack.pop(-1) # 中
                cur.val += pre
                pre = cur.val
                cur = cur.left # 左
        return root
```
