给你两棵二叉树`root`和`subRoot`。检验`root`中是否包含和`subRoot`具有相同结构和节点值的子树。如果存在，返回`true`；否则，返回`false`。

二叉树`tree`的一棵子树包括`tree`的某个节点和这个节点的所有后代节点。`tree`也可以看做它自身的一棵子树。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/2413dc19-e63d-4b4d-847d-c59bc7c2851e" width = 300 height = 300>

- 输入：root = [3,4,5,1,2], subRoot = [4,1,2]
- 输出：true

2) 示例 2：

<image src ="https://github.com/user-attachments/assets/514e4d4f-6a56-4024-a65e-a261486b3c16" width = 300 height = 300>

- 输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
- 输出：false

---
`java语法`
```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        // (1) 创建一个queue遍历root
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            // (当找到val相同的node时:)
            if(node.val == subRoot.val){
                // (2) 创建一个que遍历两棵树, 分别进行对比
                Queue<TreeNode> que = new LinkedList<>();
                boolean match = true;
                que.offer(node);
                que.offer(subRoot);
                
                while(!que.isEmpty()){
                    TreeNode node1 = que.poll();
                    TreeNode node2 = que.poll();
                    if(node1 == null && node2 != null){
                        match = false;
                        break;
                    }
                    if(node1 != null && node2 == null){
                        match = false;
                        break;
                    }
                    if(node1 == null && node2 == null)continue;
                    if(node1.val != node2.val){
                        match = false;
                        break;
                    }

                    que.offer(node1.left);
                    que.offer(node2.left);
                    que.offer(node1.right);
                    que.offer(node2.right);
                }
                if(match)return true;
                // 注意break是跳出循环,不是跳出if代码模块
                // 不需要下面这一行代码
                // if(!que.isEmpty())break;
            }
            // 没有找到node相同的val时候，继续往下遍历
            if(node.left != null)queue.offer(node.left);
            if(node.right != null)queue.offer(node.right);
        }
        return false;
    }
}
```
`python语法`
```python
class Solution(object):
    def isSubtree(self, root, subRoot):
        """
        :type root: Optional[TreeNode]
        :type subRoot: Optional[TreeNode]
        :rtype: bool
        """
        queue = [] # 设置队列遍历root
        if(root == None): # 判断特殊情况
            if(subRoot == None): return True
            else: return False
        queue.append(root)
        while(len(queue) != 0):
            node = queue.pop(0)
            if(node.left != None): queue.append(node.left)
            if(node.right != None): queue.append(node.right)
            # 判断该节点是否和subRoot的根节点val相同
            # 相同，以该节点为根节点，两棵树进行对比
            if(node.val == subRoot.val):
                queue_sub = []
                queue_sub.append(node)
                queue_sub.append(subRoot)
                con = True
                while(len(queue_sub) != 0):
                    node_root = queue_sub.pop(0)
                    node_sub = queue_sub.pop(0)
                    # 四种情况
                    if(node_root == None and node_sub == None): continue
                    if(node_root != None and node_sub == None): 
                        con = False
                        break
                    if(node_root == None and node_sub != None): 
                        con = False
                        break
                    if(node_root != None and node_sub != None):
                        if(node_root.val != node_sub.val): con = False
                    # 继续遍历，让新的节点入队列
                    queue_sub.append(node_root.left)
                    queue_sub.append(node_sub.left)
                    queue_sub.append(node_root.right)
                    queue_sub.append(node_sub.right)
                # 当以这个节点为根节点，与subRoot遍历对比完了都满足，return True
                # 否则，不return，找下一个节点为根节点 
                if(con == True):
                    return con 
        # 最终没有return Ture，就False     
        return False
```
