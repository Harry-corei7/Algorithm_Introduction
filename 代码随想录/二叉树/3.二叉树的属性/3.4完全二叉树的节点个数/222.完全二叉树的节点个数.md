给你一棵`完全二叉树`的根节点`root`，求出该树的节点个数。

`完全二叉树`的定义如下：
- 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，
- 并且最下面一层的节点都集中在该层最左边的若干位置。
- 若最底层为第 h 层（从第 0 层开始），则该层包含 1~ 2h 个节点。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/76d5a04e-6617-4387-a50d-1c0bf6bcf9a9" width = 350 height =350>

- 输入：root = [1,2,3,4,5,6]
- 输出：6

2) 示例 2：

- 输入：root = []
- 输出：0

3) 示例 3：

- 输入：root = [1]
- 输出：1

---
`java语法`
```java
class Solution {
    public int countNodes(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        if(root == null)return 0;
        que.offer(root);
        int nodeNum = 0;
        while(!que.isEmpty()){
            // 不需要层序遍历, 只需要逐个遍历即可
            // 顺序也是层序的顺序, 但没有LevelSize
            TreeNode node = que.poll();
            nodeNum++;
            if(node.left != null)que.offer(node.left);
            if(node.right != null)que.offer(node.right);
        }
        return nodeNum;
    }
}
```
`python语法`
```python
class Solution(object):
    def countNodes(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        queue = []
        node_num = 0
        if(root == None): return node_num
        queue.append(root)
        while(len(queue) != 0):
            node = queue.pop(0)
            node_num += 1
            if(node.left != None): queue.append(node.left)
            if(node.right != None): queue.append(node.right)
        return node_num
```
