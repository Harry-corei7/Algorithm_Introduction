给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

- 示例 1：

<img width="200" height="300" alt="image" src="https://github.com/user-attachments/assets/a7168b66-0607-4c9c-ae38-75bdcd6512af" />

- 输入：root = [1,2,3,null,5]
- 输出：["1->2->5","1->3"]

- 示例 2：
- 输入：root = [1]
- 输出：["1"]

---
`python语法`
```python
class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[str]
        """
        queue = [] # 设置队列用于迭代
        path_queue = [] # 设置字符串路径队列，用于收集and迭代path
        res = [] # 设置答案数组
        if(root == None): return res
        queue.append(root)
        path_queue.append(str(root.val))
        while(len(queue) != 0):
            node = queue.pop(0) # 弹出当前节点
            path = path_queue.pop(0) # 弹出最前的路径(注意路径和节点保持一致)
            if(node.left != None): 
                queue.append(node.left) # 左节点入队列
                path_queue.append(path + "->" + str(node.left.val)) # "当前节点"->左节点的path入队列
            if(node.right != None):
                queue.append(node.right) # 右节点入队列
                path_queue.append(path + "->" + str(node.right.val)) # "当前节点"->右节点的path 入队列
            # 当"当前节点"为叶子节点时，收集path
            if(node.left == None and node.right == None): 
                res.append(path)
        return res
```
