`难度: 中等`

给你二叉树的根节点`root`，返回其节点值的`层序遍历`。(即逐层地，从左到右访问所有节点)。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/716f3d5c-cd0e-4e29-82d4-03926cfb395c" height = 300 width = 300>

- 输入：root = [3,9,20,null,null,15,7]
- 输出：[[3],[9,20],[15,7]]

2) 示例 2：
- 输入：root = [1]
- 输出：[[1]]

3) 示例 3：
- 输入：root = []
- 输出：[]

---
`java语法`
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // (1) 创建result二维数组和queue队列
        List<List<Integer>> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        // (2) 特殊情况
        if(root == null)return result;
        // (3) 遍历二叉树
        queue.offer(root);
        while(!queue.isEmpty()){
            int levelsize = queue.size();
            // (4) 创建res一维数组记录当前层的node.val
            ArrayList<Integer> res = new ArrayList<>();
            for(int i = 0; i < levelsize; i++){
                TreeNode node = queue.peek();
                if(node.left!=null)queue.offer(node.left);
                if(node.right!=null)queue.offer(node.right);
                res.add(queue.poll().val);
            }
            result.add(res);
        }
        return result;
    }
}
```
---
`python语法`
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[List[int]]
        """
        res = [] # 设置二维答案数组
        queue = [] # 设置队列用于遍历
        if(root == None): # 特殊情况判断
            return queue
        queue.append(root)
        while(len(queue) != 0):
            level_size = len(queue) # (1) 层序遍历的重点，记录"当前"层的大小
            result = [] # (2) 设置一维数组储存当前层的val
            for i in range(level_size):
                node = queue[0]
                # 左右子节点入队列
                if(node.left != None): queue.append(node.left)
                if(node.right != None): queue.append(node.right)
                result.append(queue.pop(0).val)
            res.append(result)
        return res
```
