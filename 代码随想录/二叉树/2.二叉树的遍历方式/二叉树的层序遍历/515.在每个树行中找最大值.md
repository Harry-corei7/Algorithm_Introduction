`难度: 中等`

给定一棵二叉树的根节点`root`，请找出该二叉树中每一层的最大值。

1) 示例1：

<image src ="https://github.com/user-attachments/assets/3c2b9c2b-17f0-4b9b-a23b-5f93a00896a3" width = 400 height = 300>

- 输入: root = [1,3,2,5,3,null,9]
- 输出: [1,3,9]

2) 示例2：

- 输入: root = [1,2,3]
- 输出: [1,3]

---
`java语法`
```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        // (1) 创建queue队列, res数组
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        // (2) 特殊情况判断
        if(root == null)return res;
        // (3) 层序遍历算法
        queue.offer(root);
        while(!queue.isEmpty()){
            int LevelSize = queue.size();
            // 设置最大值变量，记录最大值
            int MaxValue = queue.peek().val;
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = queue.poll();
                if(node.val >= MaxValue)MaxValue= node.val;
                if(node.left != null)queue.offer(node.left);
                if(node.right != null)queue.offer(node.right);
            }
            res.add(MaxValue);
        } 
        return res;
    }
}
```
`python语法`
```python
class Solution(object):
    def largestValues(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[int]
        """
        queue = [] # 设置队列用于遍历
        res = [] # 设置答案列表
        if(root == None):
            return res
        queue.append(root)
        while(len(queue) != 0):
            level_size = len(queue)
            max_num = queue[0].val # 注意这里不能初始化=0, 因为val可能<0
            for i in range(level_size):
                node = queue.pop(0)
                if(node.left != None): queue.append(node.left)
                if(node.right != None): queue.append(node.right)
                if(node.val > max_num): 
                    max_num = node.val
            res.append(max_num)
        return res
```
