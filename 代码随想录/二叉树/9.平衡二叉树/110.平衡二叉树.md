给定一个二叉树，判断它是否是`平衡二叉树`。

`平衡二叉树`是指该树所有节点的左右子树的高度相差不超过`1`。

1) 示例 1:

<image src = "https://github.com/user-attachments/assets/0e76961e-a619-4629-8ad9-797133c235a8" width = 300 height = 300> 

- 输入：root = [3,9,20,null,null,15,7]
- 输出：true

2) 示例 2：

<image src = "https://github.com/user-attachments/assets/de732e27-840b-41ca-911b-323199bfa761" width = 400 height = 330> 

- 输入：root = [1,2,2,3,3,null,null,4,4]
- 输出：false

3) 示例 3：

- 输入：root = []
- 输出：true

---

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        if(root == null)return true;
        que.offer(root);

        while(!que.isEmpty()){
            int LevelSize = que.size();
            // 层序遍历整一个二叉树, LevelSize一层一层遍历
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = que.poll();
                // 如果左节点不是空节点
                if(node.left != null){
                    que.offer(node.left);
                    int num1 = TreeHeight(node.left);
                    int num2 = TreeHeight(node.right);
                    if((num2 - num1) > 1)
                        return false;
                } else{ // 如果左节点为空节点
                    int num = TreeHeight(node.right);
                        if(num >= 2)
                            return false;
                }
                // 如果右节点是叶子节点
                if(node.right != null){
                    que.offer(node.right);
                    int num1 = TreeHeight(node.right);
                    int num2 = TreeHeight(node.left);
                    if((num2 - num1) > 1)
                        return false;
                } else{ // 如果右节点为空节点
                    int num = TreeHeight(node.left);
                        if(num >= 2)
                            return false;
                } 
            }
        }
        return true;
    }

    // 建立函数TreeHeight
    // 返回以输入节点为根节点的树的深度
    public int TreeHeight(TreeNode root){
        Queue<TreeNode> que = new LinkedList<>();
        if(root == null)return 0;
        int height = 0;
        que.offer(root);
        while(!que.isEmpty()){
            int LevelSize = que.size();
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = que.poll();
                if(node.left!=null)que.offer(node.left);
                if(node.right!=null)que.offer(node.right);
            }
            height++;
        }
        return height;
    }
}
```
