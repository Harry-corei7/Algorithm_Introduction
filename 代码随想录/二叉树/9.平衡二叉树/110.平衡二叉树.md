给定一个二叉树，判断它是否是`平衡二叉树`。

`平衡二叉树`是指该树所有节点的左右子树的高度相差不超过`1`。

1) 示例 1:

<image src = "https://github.com/user-attachments/assets/0e76961e-a619-4629-8ad9-797133c235a8" width = 300 height = 300> 

- 输入：root = [3,9,20,null,null,15,7]
- 输出：true

2) 示例 2：

<image src = "https://github.com/user-attachments/assets/de732e27-840b-41ca-911b-323199bfa761" width = 400 height = 330> 

- 输入：root = [1,2,2,3,3,null,null,4,4]
- 输出：false

3) 示例 3：

- 输入：root = []
- 输出：true

---
`java语法`
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        if(root == null)return true;
        que.offer(root);

        while(!que.isEmpty()){
            int LevelSize = que.size();
            // 层序遍历整一个二叉树, LevelSize一层一层遍历
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = que.poll();
                // 如果左节点不是空节点
                if(node.left != null){
                    que.offer(node.left);
                    int num1 = TreeHeight(node.left);
                    int num2 = TreeHeight(node.right);
                    if((num2 - num1) > 1)
                        return false;
                } else{ // 如果左节点为空节点
                    int num = TreeHeight(node.right);
                        if(num >= 2)
                            return false;
                }
                // 如果右节点是叶子节点
                if(node.right != null){
                    que.offer(node.right);
                    int num1 = TreeHeight(node.right);
                    int num2 = TreeHeight(node.left);
                    if((num2 - num1) > 1)
                        return false;
                } else{ // 如果右节点为空节点
                    int num = TreeHeight(node.left);
                        if(num >= 2)
                            return false;
                } 
            }
        }
        return true;
    }

    // 建立函数TreeHeight
    // 返回以输入节点为根节点的树的深度
    public int TreeHeight(TreeNode root){
        Queue<TreeNode> que = new LinkedList<>();
        if(root == null)return 0;
        int height = 0;
        que.offer(root);
        while(!que.isEmpty()){
            int LevelSize = que.size();
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = que.poll();
                if(node.left!=null)que.offer(node.left);
                if(node.right!=null)que.offer(node.right);
            }
            height++;
        }
        return height;
    }
}
```
`python语法`
```python
class Solution(object):
    def level_count(slef, root):
        queue = []
        node_num = 0
        if(root == None): return node_num
        queue.append(root)
        while(len(queue) != 0):
            level_size = len(queue)
            node_num+=1
            for i in range(level_size):
                node = queue.pop(0)
                if(node.left != None): queue.append(node.left)
                if(node.right != None): queue.append(node.right)
        return node_num

    def isBalanced(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        queue = [] # 设置队列用于遍历
        if(root == None): return True
        queue.append(root)
        while(len(queue) != 0):
            node = queue.pop(0)
            level_left = self.level_count(node.left)
            level_right = self.level_count(node.right)
            num = max(level_left, level_right) - min(level_left, level_right)
            if(num > 1): return False
            # 新节点入队列
            if(node.left != None): queue.append(node.left)
            if(node.right != None): queue.append(node.right)
        return True  
```
