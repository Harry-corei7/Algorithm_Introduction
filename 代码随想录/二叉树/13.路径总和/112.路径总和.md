- 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。
- 判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
- 如果存在，返回 true ；否则，返回 false 。

- 注意:`叶子节点`是指没有子节点的节点。

1) 示例 1：

<img width="592" height="421" alt="image" src="https://github.com/user-attachments/assets/ebd26dcf-9918-4906-a01b-7c385f076af2" />

- 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
- 输出：true
- 解释：等于目标和的根节点到叶节点路径如上图所示。

2) 示例 2：
- 输入：root = [1,2,3], targetSum = 5
- 输出：false
- 解释：树中存在两条根节点到叶子节点的路径：
  - (1 --> 2): 和为 3
  - (1 --> 3): 和为 4
  - 不存在 sum = 5 的根节点到叶子节点的路径。

3) 示例 3：
- 输入：root = [], targetSum = 0
- 输出：false
- 解释：由于树是空的，所以不存在根节点到叶子节点的路径。

---
`python语法`
```python
class Solution(object):
    def hasPathSum(self, root, targetSum):
        """
        :type root: Optional[TreeNode]
        :type targetSum: int
        :rtype: bool
        """
        queue = [] # 设置队列用于遍历
        val_queue = [] # 设置队列储存val中间计算结果
        res_val = [] # 设置列表储存每一条路径的val答案
        if(root == None): return False
        queue.append(root)
        val_queue.append(root.val)
        while(len(queue) != 0):
            # 将"当前"node节点和val都弹出
            node = queue.pop(0)
            val = val_queue.pop(0)
            # 将新的节点和val入队列，注意顺序对应
            if(node.left != None):
                queue.append(node.left)
                val_queue.append(val + node.left.val)
            if(node.right != None):
                queue.append(node.right)
                val_queue.append(val + node.right.val)
            # 如果左右节点都为None，说明次节点为叶子节点，将这个弹出的val保留到路径结果的列表
            if(node.left == None and node.right == None):
                res_val.append(val)
        if(targetSum in res_val): return True
        else: return False
```
