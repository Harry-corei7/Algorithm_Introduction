`难度: 中等`

- 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有**从根节点到叶子节点**路径总和等于给定目标和的路径。
- 叶子节点 是指没有子节点的节点。

1) 示例 1：

<img width="592" height="421" alt="image" src="https://github.com/user-attachments/assets/01823b9a-b34d-4dc7-b294-9147f404c77c" />

- 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
- 输出：[[5,4,11,2],[5,8,4,5]]

2) 示例 2：

<img width="212" height="181" alt="image" src="https://github.com/user-attachments/assets/7efbf91b-ee29-4600-8382-ca26b393cff9" />

- 输入：root = [1,2,3], targetSum = 5
- 输出：[]

3) 示例 3：

- 输入：root = [1,2], targetSum = 0
- 输出：[]

---
`python语法`

`解法1: 记录所有路径的节点列表和val，筛选符合targetSum的return`
```python
class Solution(object):
    def pathSum(self, root, targetSum):
        """
        :type root: Optional[TreeNode]
        :type targetSum: int
        :rtype: List[List[int]]
        """
        queue = [] # 设置队列用于遍历
        val_sum_queue = [] # (1)设置val队列储存中间计算结果
        node_list_queue = [] # (2)设置node列表队列储存node中间结果
        res_val = [] # (1)设置res_val储存每一条路径的val最终结果
        res_node_list = [] # (2)设置res_node_list储存每一条路径的node列表最终结果
        if(root == None): return []
        # 初始头节点入队列
        queue.append(root)
        val_sum_queue.append(root.val)
        node_list_queue.append([root.val])
        while(len(queue) != 0): # 遍历二叉树
            # 弹出三个元素，注意三个元素顺序一一对应
            node = queue.pop(0)
            val = val_sum_queue.pop(0)
            node_list = node_list_queue.pop(0)
            if(node.left != None):
                queue.append(node.left)
                # 不能用val+=node.left.val，因为+=表达式没有返回值，而且val被更改！
                val_sum_queue.append(val+node.left.val) 
                # 这里必须新建数组new_node_list = node_list.copy(), 保持node_list不受影响
                new_node_list = node_list[:]; new_node_list.append(node.left.val); node_list_queue.append(new_node_list)
            if(node.right != None):
                queue.append(node.right)
                # 不能用val+=node.right.val，因为+=表达式没有返回值，而且val被更改！
                val_sum_queue.append(val+node.right.val) 
                # 这里必须新建数组new_node_list = node_list.copy(), 保持node_list不受影响
                new_node_list = node_list[:]; new_node_list.append(node.right.val); node_list_queue.append(new_node_list)
            # 如果是叶子节点，记录这一路径最终答案
            if(node.left == None and node.right == None):
                res_val.append(val)
                res_node_list.append(node_list)
        # 判断符合targetSum的路径，处理并返回答案
        final_res = []
        for i in range(len(res_val)):
            if(res_val[i] == targetSum):
                final_res.append(res_node_list[i])
        return final_res
```
