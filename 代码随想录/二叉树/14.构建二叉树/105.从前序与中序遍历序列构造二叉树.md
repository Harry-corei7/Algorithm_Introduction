`难度: 中等`

- 给定两个整数数组**preorder**和**inorder**
- 其中**preorder**是二叉树的先序遍历，**inorder**是同一棵树的中序遍历，请构造二叉树并返回其根节点。

- 示例 1:

<img width="277" height="302" alt="image" src="https://github.com/user-attachments/assets/d55768c2-4d07-42a2-affe-8923c9c6a7ac" />

- 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
- 输出: [3,9,20,null,null,15,7]

- 示例 2:

- 输入: preorder = [-1], inorder = [-1]
- 输出: [-1]

---


---

`python算法`
```python
class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: Optional[TreeNode]
        """
        # (1) 如果数组大小为空，说明是空节点
        if(len(preorder) == 0): return None

        # (2) 不为空，则取前序遍历的的第一个元素，作为"当前节点"的val
        val = preorder[0]
        root = TreeNode(val = val)

        # (3) 找切割点
        delimiter_index = 0
        for i in range(len(inorder)):
            if(inorder[i] == val):
                delimiter_index = i
                break
        
        # (4) 根据切割点，对中序遍历数组进行切割，获得左中序/右中序
        left_inorder = inorder[:delimiter_index]
        right_inorder = inorder[delimiter_index+1:]

        # (5) 根据左中序/右中序，对前序遍历数组进行切割，获得左前序/右前序
        left_preorder = preorder[1:len(left_inorder)+1]
        right_preorder = preorder[len(left_inorder)+1:]

        # (6) 递归: 利用buildTree遍历左右节点
        root.left = self.buildTree(left_preorder, left_inorder)
        root.right = self.buildTree(right_preorder, right_inorder)

        return root
```
