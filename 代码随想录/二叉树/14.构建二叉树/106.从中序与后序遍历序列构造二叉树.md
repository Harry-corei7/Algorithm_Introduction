`难度: 中等`

- 给定两个整数数组**inorder**和**postorder**
- 其中**inorder**是二叉树的中序遍历的val数组，**postorder**是同一棵树的后序遍历的val数组，请你构造并返回这颗**二叉树**。

- 示例 1:
<img width="277" height="302" alt="image" src="https://github.com/user-attachments/assets/09a59b90-26c7-43c0-8e1a-b16b8d5ad0ef" />

- 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
- 输出：[3,9,20,null,null,15,7]

- 示例 2:
- 单节点[-1]
- 输入：inorder = [-1], postorder = [-1]
- 输出：[-1]

---

`思路流程图`
<img width="1292" height="786" alt="image" src="https://github.com/user-attachments/assets/3d36833e-4215-4f9c-9d9a-6fe7cc2e6ae5" />

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

---

`python语法`
```python
class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: Optional[TreeNode]
        """
        # (1) 如果数组大小为空，说明是空节点
        if(len(postorder) == 0): return None
        
        # (2) 如果不为空，取后序遍历数组的最后一个元素作为"当前"节点val
        # 这是由后序遍历的特性，数组最后一个必为中节点(当前节点)
        val = postorder[-1]
        root = TreeNode(val = val)
        # 判断是否是叶子节点(小剪枝，不写也没事)
        if(len(postorder) == 1): return root

        # (3) 找切割点
        delimiter_index = 0
        for i in range(len(inorder)):
            if(inorder[i] == val):
                delimiter_index = i
                break
        
        # (4) 切割中序数组，得到 中序左数组和中序右数组(顺序: 先中序，后后续)
        left_inorder = inorder[:delimiter_index]
        right_inorder = inorder[delimiter_index + 1:] # +1将"当前"节点作为头节点跳过

        # (5) 切割后序数组，得到 后序左数组和后序右数组
        # 后序左数组/右数组 等同于 中序左数组/右数组
        left_postorder = postorder[:len(left_inorder)]
        right_postorder = postorder[len(left_inorder): len(postorder)-1] # -1将"当前"节点作为头节点跳过

        # (6) 递归: 继续buildTree
        root.left = self.buildTree(left_inorder, left_postorder)
        root.right = self.buildTree(right_inorder, right_postorder)

        return root
```
