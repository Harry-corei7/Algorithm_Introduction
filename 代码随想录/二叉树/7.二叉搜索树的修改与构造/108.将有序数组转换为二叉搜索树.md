- 给你一个整数数组`nums`，其中元素已经按`升序`排列，请你将其转换为一棵`平衡`二叉搜索树。

- 示例 1：
- 输入：nums = [-10,-3,0,5,9]
- 输出：[0,-3,9,-10,null,5]
- <img width="302" height="222" alt="image" src="https://github.com/user-attachments/assets/2544087e-3c2d-47c6-b874-b58f3b9b17e0" />
- 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
- <img width="302" height="222" alt="image" src="https://github.com/user-attachments/assets/967a863d-0302-40c3-aaf6-b4c823254100" />

- 示例 2：
- 输入：nums = [1,3]
- 输出：[3,1]
- <img width="342" height="142" alt="image" src="https://github.com/user-attachments/assets/277fe338-d2f5-4113-ac6b-0c7607482d8a" />
- 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。

---
`python语法，递归法`
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def traversal(self, nums, left, right):
        if(left > right): # 当左坐标>右坐标，为空节点
            return None
        middle = (left + right)//2
        root = TreeNode(nums[middle])
        # 递归，定义左右子节点
        root.left = self.traversal(nums, left, middle-1)
        root.right = self.traversal(nums, middle+1, right)
        # 递归返回当前节点
        return root
        

    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: Optional[TreeNode]
        """
        root = self.traversal(nums, 0, len(nums)-1)
        return root
```
