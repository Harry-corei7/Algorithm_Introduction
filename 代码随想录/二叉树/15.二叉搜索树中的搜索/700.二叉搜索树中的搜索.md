- 给定二叉搜索树（BST）的根节点`root`和一个整数值`val`。
- 你需要在`BST`中找到节点值等于`val`的节点。
- 返回以该节点为根的子树。
- 如果节点不存在，则返回`null`。

- 示例 1:

<img width="422" height="302" alt="image" src="https://github.com/user-attachments/assets/c6b5372d-5442-4803-a68a-41c08a5e8801" />

- 输入：root = [4,2,7,1,3], val = 2
- 输出：[2,1,3]

- 示例 2:

<img width="422" height="302" alt="image" src="https://github.com/user-attachments/assets/3a50b500-f44c-4d7b-a723-cdc4d44d00b1" />

- 输入：root = [4,2,7,1,3], val = 5
- 输出：[]

---

- 二叉搜索树是一个有序树：
1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3) 它的左、右子树也分别为二叉搜索树
- 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。

---
`python语法`

`简单的层序遍历`
```python
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: Optional[TreeNode]
        :type val: int
        :rtype: Optional[TreeNode]
        """
        # 设置队列用于遍历
        queue = []
        # 特殊判断
        if(root == None): return root
        # 入队列
        queue.append(root)
        # 进行遍历
        while(len(queue) != 0):
            node = queue.pop(0)
            if(node.val == val):
                return node
            if(node.left != None): queue.append(node.left)
            if(node.right != None): queue.append(node.right)
        return None
```

`运用二叉搜索树的特性的遍历`
```python

```
