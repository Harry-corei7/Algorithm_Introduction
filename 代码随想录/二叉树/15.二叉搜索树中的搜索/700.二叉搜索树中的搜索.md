- 给定二叉搜索树（BST）的根节点`root`和一个整数值`val`。
- 你需要在`BST`中找到节点值等于`val`的节点。
- 返回以该节点为根的子树。
- 如果节点不存在，则返回`null`。

- 示例 1:

<img width="422" height="302" alt="image" src="https://github.com/user-attachments/assets/c6b5372d-5442-4803-a68a-41c08a5e8801" />

- 输入：root = [4,2,7,1,3], val = 2
- 输出：[2,1,3]

- 示例 2:

<img width="422" height="302" alt="image" src="https://github.com/user-attachments/assets/3a50b500-f44c-4d7b-a723-cdc4d44d00b1" />

- 输入：root = [4,2,7,1,3], val = 5
- 输出：[]

---

- 二叉搜索树是一个有序树：
1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3) 它的左、右子树也分别为二叉搜索树
- 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。

---
`python语法`

`迭代: 简单的层序遍历`
```python
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: Optional[TreeNode]
        :type val: int
        :rtype: Optional[TreeNode]
        """
        # 设置队列用于遍历
        queue = []
        # 特殊判断
        if(root == None): return root
        # 入队列
        queue.append(root)
        # 进行遍历
        while(len(queue) != 0):
            node = queue.pop(0)
            if(node.val == val):
                return node
            if(node.left != None): queue.append(node.left)
            if(node.right != None): queue.append(node.right)
        return None
```

`迭代: 运用二叉搜索树的特性的遍历`
```python
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: Optional[TreeNode]
        :type val: int
        :rtype: Optional[TreeNode]
        """
        node = root
        # 进行遍历
        while(node != None):
            if(node.val == val): return node
            # val大，去二叉搜索树的右分支
            if(node.val < val): node = node.right
            # val小，去二叉搜索树的左分支
            if(node.val > val): node = node.left
        return None # 这里也可以写return node，因为跳出循环的node == None(代表遍历结束，此时整个二叉树里面都没val)
```
- 使用变量`node`进行遍历，不需要队列，因为只需要对一条分支进行搜索

`递归: 运用二叉搜索树的特性的遍历(等同于迭代)`
```python
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: Optional[TreeNode]
        :type val: int
        :rtype: Optional[TreeNode]
        """
        node = root
        if(node == None or node.val == val): return node
        # 进行递归
        # 注意: 不要忘记设置result变量将递归函数返回值接住
        result = None
        # val大，去二叉搜索树的右分支
        if(node.val < val): result = self.searchBST(node.right, val)
        # val小，去二叉搜索树的左分支
        if(node.val > val): result = self.searchBST(node.left, val)
        
        return result
```
