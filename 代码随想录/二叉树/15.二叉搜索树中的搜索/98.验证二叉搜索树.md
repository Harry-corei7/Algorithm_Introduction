`难度: 中等`

- 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

- 有效 二叉搜索树定义如下：
  - 节点的左子树只包含 **严格小于** 当前节点的数。
  - 节点的右子树只包含 **严格大于** 当前节点的数。
  - 所有左子树和右子树自身必须也是二叉搜索树。

---

- 二叉搜索树是一个有序树：
1) 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2) 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3) 它的左、右子树也分别为二叉搜索树
- 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。
- 对于二叉搜索树的验证遍历方式
1) 采用中序遍历: 左中右
2) 因为: 左<中<右
---
`python语法`

`统一迭代法:`

```python
class Solution(object):
    def isValidBST(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        stack = []
        pre = None # 记录上一个节点
        if(root == None): return False
        stack.append(root)
        while(len(stack) != 0):
            cur = stack.pop(-1) # 查看栈顶元素
            # 按照右-中-左的顺序入栈（中序遍历的逆序）
            if(cur != None):
                if(cur.right != None): stack.append(cur.right)
                stack.append(cur)
                stack.append(None)
                if(cur.left != None): stack.append(cur.left)
            else:
                temp = stack.pop(-1) # 弹出要访问的节点
                # 检查BST特性: 当前节点值必须大于前一个节点值(左<中<右)
                if(pre != None and pre.val >= temp.val): return False
                # 更新pre
                pre = temp
        return True
```

