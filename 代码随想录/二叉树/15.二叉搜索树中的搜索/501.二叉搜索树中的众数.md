- 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有**众数**（即，出现频率最高的元素）。
- 如果树中有不止一个众数，可以按`任意顺序`返回。
- 假定 BST 满足如下定义：
  1) 结点左子树中所含节点的值 小于等于 当前节点的值
  2) 结点右子树中所含节点的值 大于等于 当前节点的值
  3) 左子树和右子树都是二叉搜索树

- `温馨提示: 将中序遍历的搜索二叉树看成有序数组`
---

`python语法`
```python
class Solution(object):
    def findMode(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[int]
        """
        res = [] # 设置答案数组
        pre = None # 设置pre指向上一个元素
        stack = [] # 设置栈用于遍历二叉树

        count = 0 # 设置count用于计数
        maxCount = 0 # 设置maxCount用于记录"当前"最大数
        if(root == None): return None # 特殊情况判断
        stack.append(root)
        while(len(stack) != 0):
            node = stack.pop(-1)
            # 中序: 左中右 逆序: 右中左
            if(node != None): 
                if(node.right != None): stack.append(node.right)
                stack.append(node)
                stack.append(None)
                if(node.left != None): stack.append(node.left)
            else:
                temp = stack.pop(-1)
                # 三种情况对count进行更新
                # 本题的解法关键: 
                # (1) 将中序遍历的搜索二叉树看成有序数组
                # (2) count, maxCount记数
                if(pre == None): count = 1 # (1) pre==None，计数=1初始化
                elif(pre != None and pre.val == temp.val): count += 1 # (2) pre.val与当前相等，计数+1
                else: count = 1 # (3) pre.val与当前相等，计数=1初始化
                # 对pre指针进行更新
                pre = temp
                # 判断是否填充到res
                if(count == maxCount): res.append(pre.val)
                if(count > maxCount): 
                    maxCount = count
                    while(len(res) != 0): res.pop()
                    res.append(pre.val)
        return res
```
