`难度: 中等`

-给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

- 百度百科中最近公共祖先的定义为：
  - 对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x
  - 满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。

1) 示例 1：

<img width="200" height="190" alt="image" src="https://github.com/user-attachments/assets/a8fb22d0-a0d5-4893-a283-ee118a26ca56" />

- 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
- 输出：3
- 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。



2) 示例 2：

<img width="200" height="190" alt="image" src="https://github.com/user-attachments/assets/0981137f-7fb0-45e6-870d-c3b3cab0c343" />

- 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
- 输出：5
- 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

---

`python语法: 递归法`
```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        # 最末端递归结束条件，获得p, q, 或None
        if(root == None or root == p or root == q): 
            return root

        # 递归: 后续遍历
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        # 判断条件，将return的结果向上递
        if(left == None and right == None): 
            return None 
            # 如果left, right两个分支均为None, 即没用找到p, q
        elif(left == None and right != None):
            return right 
            # 如果left分支无结果, right分支获取节点
            # 该节点即为right分支第一个获得的节点，被往上递，最终返回
        elif(left != None and right == None):
            return left
            # 如果right分支无结果，left分支获取节点
            # 该节点即为left分支第一个获得的节点，被往上递，最终返回
        else:
            return root
            # 若left/right分支都有返回值，则返回根节点，并往上递，最终返回
```
- 流程图如下所示:

<img width="1036" height="776" alt="image" src="https://github.com/user-attachments/assets/4b9f49df-73e8-4870-98f8-39ecd21bc647" />

- 那么我给大家归纳如下三点：
1) 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。
2) 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
3) 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。
- 可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。
- 本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。
