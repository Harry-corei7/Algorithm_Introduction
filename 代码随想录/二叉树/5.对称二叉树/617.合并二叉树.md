- 给你两棵二叉树：`root1`和`root2`。
- 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。
- 你需要将这两棵树合并成一棵新二叉树。
- 合并的规则是：
  - 如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；
  - 否则，不为 null 的节点将直接作为新二叉树的节点。
- 返回合并后的二叉树。
- 注意: 合并过程必须从两个树的根节点开始。

- 示例 1：

<img width="1112" height="302" alt="image" src="https://github.com/user-attachments/assets/9c835b00-b407-4e25-8263-d6bbe5488bbc" />

- 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
- 输出：[3,4,5,5,4,null,7]

- 示例 2：

- 输入：root1 = [1], root2 = [1,2]
- 输出：[2,2]

---
`python语法`

`错误的做法: node_1 = None导致我无法影响原树结构，因为None代表"空，没有"，node_1 = None当然也就无法和原树起到任何关联关系`

- 情况1：非空节点
```python
node_1 = queue.pop(0)  # node_1 是真实的 TreeNode 对象
node_1.val = 5  # 修改的是真实对象的值，会影响原树
```
- 情况2：None 节点
```python
node_1 = queue.pop(0)  # node_1 是 None
node_1 = TreeNode(5)   # 问题在这里！
```

`错误做法示例`
```python
class Solution(object):
    def mergeTrees(self, root1, root2):
        """
        :type root1: Optional[TreeNode]
        :type root2: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """
        # 设置队列用于遍历
        queue = []
        # 特殊情况判断
        if(root1 == None): return root2
        if(root2 == None): return root1
        # "当前"节点入队列
        queue.append(root1)
        queue.append(root2)
        # 遍历二叉树，同时处理"两棵树"的情况在"二叉树对称"问题也遇到过
        while(len(queue) != 0):
            node_1 = queue.pop(0)
            node_2 = queue.pop(0)
            # (1) 当前节点均不是None
            if((node_1 != None) and (node_2 != None)): node_1.val = node_1.val + node_2.val
            # (2) 左节点是None
            if((node_1 == None) and (node_2 != None)): node_1 = TreeNode(val = node_2.val)
            # (3) 右节点是None
            if((node_1 != None) and (node_2 == None)): node_1.val = node_1.val
            # (4) 左右节点均为None
            if((node_1 == None) and (node_2 == None)): continue

            # 新节点入队列
            if(node_1 != None): queue.append(node_1.left)
            if(node_2 != None): queue.append(node_2.left)
            if(node_1 != None): queue.append(node_1.right)
            if(node_2 != None): queue.append(node_2.right)
        return root1
```




---

