给你两棵二叉树`root`和`subRoot`。检验`root`中是否包含和`subRoot`具有相同结构和节点值的子树。如果存在，返回`true`；否则，返回`false`。

二叉树`tree`的一棵子树包括`tree`的某个节点和这个节点的所有后代节点。`tree`也可以看做它自身的一棵子树。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/2413dc19-e63d-4b4d-847d-c59bc7c2851e" width = 300 height = 300>

- 输入：root = [3,4,5,1,2], subRoot = [4,1,2]
- 输出：true

2) 示例 2：

<image src ="https://github.com/user-attachments/assets/514e4d4f-6a56-4024-a65e-a261486b3c16" width = 300 height = 300>

- 输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
- 输出：false

---

```java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        // (1) 创建一个queue遍历root
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            // (当找到val相同的node时:)
            if(node.val == subRoot.val){
                // (2) 创建一个que遍历两棵树, 分别进行对比
                Queue<TreeNode> que = new LinkedList<>();
                boolean match = true;
                que.offer(node);
                que.offer(subRoot);
                
                while(!que.isEmpty()){
                    TreeNode node1 = que.poll();
                    TreeNode node2 = que.poll();
                    if(node1 == null && node2 != null){
                        match = false;
                        break;
                    }
                    if(node1 != null && node2 == null){
                        match = false;
                        break;
                    }
                    if(node1 == null && node2 == null)continue;
                    if(node1.val != node2.val){
                        match = false;
                        break;
                    }

                    que.offer(node1.left);
                    que.offer(node2.left);
                    que.offer(node1.right);
                    que.offer(node2.right);
                }
                if(match)return true;
                // 注意break是跳出循环,不是跳出if代码模块
                // 不需要下面这一行代码
                // if(!que.isEmpty())break;
            }
            // 没有找到node相同的val时候，继续往下遍历
            if(node.left != null)queue.offer(node.left);
            if(node.right != null)queue.offer(node.right);
        }
        return false;
    }
}
```
