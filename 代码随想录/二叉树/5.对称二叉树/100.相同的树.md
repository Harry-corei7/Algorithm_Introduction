给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/76f8c807-3125-4741-9f96-1d4934a881a7" width = 600 height = 270>

- 输入：p = [1,2,3], q = [1,2,3]
- 输出：true

2) 示例 2：

<image src = "https://github.com/user-attachments/assets/95e1bc84-1e22-45d0-8d76-04cd5af2124e" width = 600 height = 270>

- 输入：p = [1,2], q = [1,null,2]
- 输出：false

3) 示例 3：

<image src = "https://github.com/user-attachments/assets/ca4825e6-d97c-4b85-9883-4a26586a7fc5" width = 600 height = 270>

- 输入：p = [1,2,1], q = [1,1,2]
- 输出：false

---
`java语法`
```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        Queue<TreeNode> queue = new LinkedList<>();
        
        queue.offer(p);
        queue.offer(q);
        while(!queue.isEmpty()){
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();

            // 注意null没有.val, 所以
            // (1) 关于node1和node2 == null 必须分情况进行判断
            // (2) node1 == null && node2 == null判断必须在前
            // (3) node1.val != node2.val判断必须在后
            if(node1 == null && node2 != null)return false;
            if(node1 != null && node2 == null)return false;
            
            if(node1 == null && node2 == null)continue;
            if(node1.val != node2.val)return false;

            // 注意单向队列的入队顺序
            queue.offer(node1.left);
            queue.offer(node2.left);
            queue.offer(node1.right);
            queue.offer(node2.right);
        }
        return true;
    }
}
```
`python语法`
```python
class Solution(object):
    def isSameTree(self, p, q):
        """
        :type p: Optional[TreeNode]
        :type q: Optional[TreeNode]
        :rtype: bool
        """
        queue = []
        queue.append(p)
        queue.append(q) # 在append前，不判断节点是否None
        con = True
        while(len(queue) != 0): # 保留层序遍历的遍历方式
            node_p = queue.pop(0)
            node_q = queue.pop(0) # 在pop后，判断节点是否None，作为判断二叉树相等的一部分
            if(node_p == None and node_q == None):
                continue
            if(node_p == None and node_q != None):
                con = False
                break
            if(node_p != None and node_q == None):
                con = False
                break
            if(node_p.val != node_q.val):
                con = False
                break
            queue.append(node_p.left)
            queue.append(node_q.left)
            queue.append(node_p.right)
            queue.append(node_q.right)
        return con
```
