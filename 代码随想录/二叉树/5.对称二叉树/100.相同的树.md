给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/76f8c807-3125-4741-9f96-1d4934a881a7" width = 600 height = 270>

- 输入：p = [1,2,3], q = [1,2,3]
- 输出：true

2) 示例 2：

<image src = "https://github.com/user-attachments/assets/95e1bc84-1e22-45d0-8d76-04cd5af2124e" width = 600 height = 270>

- 输入：p = [1,2], q = [1,null,2]
- 输出：false

3) 示例 3：

<image src = "https://github.com/user-attachments/assets/ca4825e6-d97c-4b85-9883-4a26586a7fc5" width = 600 height = 270>

- 输入：p = [1,2,1], q = [1,1,2]
- 输出：false

---

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        Queue<TreeNode> queue = new LinkedList<>();
        
        queue.offer(p);
        queue.offer(q);
        while(!queue.isEmpty()){
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();

            // 注意null没有.val, 所以
            // (1) 关于node1和node2 == null 必须分情况进行判断
            // (2) node1 == null && node2 == null判断必须在前
            // (3) node1.val != node2.val判断必须在后
            if(node1 == null && node2 != null)return false;
            if(node1 != null && node2 == null)return false;
            
            if(node1 == null && node2 == null)continue;
            if(node1.val != node2.val)return false;

            // 注意单向队列的入队顺序
            queue.offer(node1.left);
            queue.offer(node2.left);
            queue.offer(node1.right);
            queue.offer(node2.right);
        }
        return true;
    }
}
```
