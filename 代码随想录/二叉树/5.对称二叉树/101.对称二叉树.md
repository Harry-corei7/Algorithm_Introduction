给你一个二叉树的根节点`root`， 检查它是否轴对称。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/9ad18226-33c4-4468-bab1-d49626f5af15" width = 300 height = 270>

- 输入：root = [1,2,2,3,4,4,3]
- 输出：true

2) 示例 2：

<image src = "https://github.com/user-attachments/assets/1e68f875-57d0-4a5e-a309-31c33d39e303" width = 300 height = 270>

- 输入：root = [1,2,2,null,3,null,3]
- 输出：false

---
`java语法`
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        // (1) 使用双向队列, 但双向队列不允许null节点入队
        // Deque<TreeNode> deque = new ArrayDeque<>();
        // deque.offerFirst(null);
        if(root == null)return false;
        // (2) 使用单向队列, 单向队列允许null节点入队
        Queue<TreeNode> queue = new LinkedList<>();
        // (2.1) 一开始让root.left和root.right入队, 以便后续两两对比
        queue.offer(root.left);
        queue.offer(root.right);

        while(!queue.isEmpty()){
            // (2.2) 两两对比
            TreeNode NodeLeft = queue.poll();
            TreeNode NodeRight = queue.poll();

            if(NodeLeft == null && NodeRight == null){
                continue; // null无法对比.val
            }
            if(NodeLeft == null && NodeRight != null){
                return false;
            }
            if(NodeLeft != null && NodeRight == null){
                return false;
            }
            if(NodeLeft.val != NodeRight.val){
                return false;
            }
            // 单向队列和双向队列, 这里的入队顺序不同
            queue.offer(NodeLeft.right);
            queue.offer(NodeRight.left);
            queue.offer(NodeLeft.left);
            queue.offer(NodeRight.right);
        }
        return true;
    }
}
```
`python语法`
```python
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        queue = []
        if(root ==  None):
            return False
        queue.append(root.left)
        queue.append(root.right)
        while(len(queue) != 0):
            node_left = queue.pop(0)
            node_right = queue.pop(0)
            # 两两对比节点，如果都为空则continue跳过
            if(node_left == None and node_right == None): continue
            if(node_left != None and node_right == None): return False
            if(node_left == None and node_right != None): return False
            if(node_left != None and node_right != None):
                if(node_left.val != node_right.val): return False
            # 新节点入队列，注意入队列的顺序，两两相邻节点作比较
            queue.append(node_left.left)
            queue.append(node_right.right)
            queue.append(node_left.right)
            queue.append(node_right.left)
        return True
```
