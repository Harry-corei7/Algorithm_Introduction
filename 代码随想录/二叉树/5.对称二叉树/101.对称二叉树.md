给你一个二叉树的根节点`root`， 检查它是否轴对称。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/9ad18226-33c4-4468-bab1-d49626f5af15" width = 300 height = 300>
- 输入：root = [1,2,2,3,4,4,3]
- 输出：true

2) 示例 2：

<image src = "https://github.com/user-attachments/assets/1e68f875-57d0-4a5e-a309-31c33d39e303" width = 300 height = 300>
- 输入：root = [1,2,2,null,3,null,3]
- 输出：false

---

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        // (1) 使用双向队列, 但双向队列不允许null节点入队
        // Deque<TreeNode> deque = new ArrayDeque<>();
        // deque.offerFirst(null);
        if(root == null)return false;
        // (2) 使用单向队列, 单向队列允许null节点入队
        Queue<TreeNode> queue = new LinkedList<>();
        // (2.1) 一开始让root.left和root.right入队, 以便后续两两对比
        queue.offer(root.left);
        queue.offer(root.right);

        while(!queue.isEmpty()){
            // (2.2) 两两对比
            TreeNode NodeLeft = queue.poll();
            TreeNode NodeRight = queue.poll();

            if(NodeLeft == null && NodeRight == null){
                continue; // null无法对比.val
            }
            if(NodeLeft == null && NodeRight != null){
                return false;
            }
            if(NodeLeft != null && NodeRight == null){
                return false;
            }
            if(NodeLeft.val != NodeRight.val){
                return false;
            }
            // 单向队列和双向队列, 这里的入队顺序不同
            queue.offer(NodeLeft.right);
            queue.offer(NodeRight.left);
            queue.offer(NodeLeft.left);
            queue.offer(NodeRight.right);
        }
        return true;
    }
}
```
