`难度：中等`

- 给你二叉搜索树的根节点`root`，同时给定最小边界`low`和最大边界`high`。
- 通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。
- 修剪树**不应该**改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。
- 可以证明，存在**唯一的答案**。

- 所以结果应当返回修剪好的二叉搜索树的新的根节点。
- **注意**，根节点可能会根据给定的边界发生改变。

- 示例 1：
<img width="722" height="202" alt="image" src="https://github.com/user-attachments/assets/f733b778-43da-40d6-9991-56c95b03a8a1" />

- 输入：root = [1,0,2], low = 1, high = 2
- 输出：[1,null,2]

- 示例 2：
<img width="722" height="444" alt="image" src="https://github.com/user-attachments/assets/38faca3b-a345-48e4-93ce-08cefaad5e5f" />

- 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
- 输出：[3,2,null,1]

---
`递归法经典错误点`
```python
class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: Optional[TreeNode]
        :type low: int
        :type high: int
        :rtype: Optional[TreeNode]
        """
        # 将遍历结束None / 双边越界 简单地都返回None
        # 忽视了搜索树的复杂特性，双边越界，需要进一步看子树
        if(root == None or root.val < low or root.val > high): 
            return None
        
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)

        return root
```
<img width="700" height="450" alt="image" src="https://github.com/user-attachments/assets/3a1bcdfb-08a6-46e3-b882-8d317d8d701e" />

- 从图中可以看出需要重构二叉树，想想是不是本题就有点复杂了。
- 其实不用重构那么复杂。
- 在上图中我们发现`节点0`并不符合区间要求，那么将`节点0`的右孩子`节点2`直接赋给`节点3`的左孩子就可以了（就是把节点0从二叉树中移除）
- 如图：
<img width="400" height="350" alt="image" src="https://github.com/user-attachments/assets/7c5ec3f4-8e7e-4ad6-926d-6952d57dde25" />

---
`python语法：递归法`
```python
class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: Optional[TreeNode]
        :type low: int
        :type high: int
        :rtype: Optional[TreeNode]
        """
        # 判断当前节点
        if(root == None): # 节点为None，遍历结束，返回None
            return None
        elif(root.val < low): # 当左边越界，判断右子树，寻找区间[low, high]的节点
            return self.trimBST(root.right, low, high)
        elif(root.val > high): # 当右边越界，判断左子树，寻找区间[low, high]的节点
            return self.trimBST(root.left, low, high)
        
        # 向下进行遍历
        root.left = self.trimBST(root.left, low, high) # 将左子树进行层层判断，最终返回修剪过的左子树
        root.right = self.trimBST(root.right, low, high) # 将右子树进行层层判断，最终返回修剪过的右子树

        return root # 每个节点的返回，以及最终root的返回
```
