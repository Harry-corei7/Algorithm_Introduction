`难度：中等`

- 给你二叉搜索树的根节点`root`，同时给定最小边界`low`和最大边界`high`。
- 通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。
- 修剪树**不应该**改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。
- 可以证明，存在**唯一的答案**。

- 所以结果应当返回修剪好的二叉搜索树的新的根节点。
- **注意**，根节点可能会根据给定的边界发生改变。

- 示例 1：
<img width="722" height="202" alt="image" src="https://github.com/user-attachments/assets/f733b778-43da-40d6-9991-56c95b03a8a1" />

- 输入：root = [1,0,2], low = 1, high = 2
- 输出：[1,null,2]

- 示例 2：
<img width="722" height="444" alt="image" src="https://github.com/user-attachments/assets/38faca3b-a345-48e4-93ce-08cefaad5e5f" />

- 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
- 输出：[3,2,null,1]

---
`递归法经典错误点`
```python
class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: Optional[TreeNode]
        :type low: int
        :type high: int
        :rtype: Optional[TreeNode]
        """
        # 将遍历结束None / 双边越界 简单地都返回None
        # 忽视了搜索树的复杂特性，双边越界，需要进一步看子树
        if(root == None or root.val < low or root.val > high): 
            return None
        
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)

        return root
```
<img width="700" height="450" alt="image" src="https://github.com/user-attachments/assets/3a1bcdfb-08a6-46e3-b882-8d317d8d701e" />

- 从图中可以看出需要重构二叉树，想想是不是本题就有点复杂了。
- 其实不用重构那么复杂。
- 在上图中我们发现`节点0`并不符合区间要求，那么将`节点0`的右孩子`节点2`直接赋给`节点3`的左孩子就可以了（就是把节点0从二叉树中移除）
- 如图：
<img width="400" height="350" alt="image" src="https://github.com/user-attachments/assets/7c5ec3f4-8e7e-4ad6-926d-6952d57dde25" />

---
`python语法：递归法`
```python
class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: Optional[TreeNode]
        :type low: int
        :type high: int
        :rtype: Optional[TreeNode]
        """
        # 判断当前节点
        if(root == None): # 节点为None，遍历结束，返回None
            return None
        elif(root.val < low): # 当左边越界，判断右子树，寻找区间[low, high]的节点
            return self.trimBST(root.right, low, high)
        elif(root.val > high): # 当右边越界，判断左子树，寻找区间[low, high]的节点
            return self.trimBST(root.left, low, high)
        
        # 若当前节点在区间[low, high]，则向下进行遍历
        root.left = self.trimBST(root.left, low, high) # 将左子树进行层层判断，最终返回修剪过的左子树
        root.right = self.trimBST(root.right, low, high) # 将右子树进行层层判断，最终返回修剪过的右子树
        return root 
```
---
`python语法：迭代法`
```python
class Solution(object):
    def trimBST(self, root, low, high):
        """
        :type root: Optional[TreeNode]
        :type low: int
        :type high: int
        :rtype: Optional[TreeNode]
        """
        if(root ==  None): return None
        # 找到新的根节点（在范围内的第一个节点）
        while(root != None and (root.val < low or root.val > high)):
            if(root.val < low):
                root = root.right # 小于low往右走
            elif(root.val > high):
                root = root.left # 大于high往左走
        if(root == None): # 没找到，提前返回None
            return None

        # 处理左子树：移除所有小于low的节点
        # 指向root(左节点的根节点，便于删除)
        node = root
        while(node != None):
            # 如果左子节点存在且值小于low
            while(node.left != None and node.left.val < low):
                # 左子节点的右子树可能包含有效节点
                node.left = node.left.right
            node = node.left # 继续向左检查(继续判断已经符合条件的左节点，的左节点)

        # 处理右子树：移除所有大于high的节点
        # 指向root(右节点的根节点，便于删除)
        node = root
        while(node != None):
            # 如果右子节点存在且值大于high
            while(node.right != None and node.right.val > high):
                # 右子节点的左子树可能包含有效节点
                node.right = node.right.left
            node = node.right # 继续向右检查(继续判断已经符合条件的右节点，的右节点)
        
        return root
```
