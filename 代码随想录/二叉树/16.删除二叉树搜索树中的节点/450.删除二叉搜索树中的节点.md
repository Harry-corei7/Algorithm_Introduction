`难度：中等`

- 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
- 一般来说，删除节点可分为两个步骤：
1) 首先找到需要删除的节点；
2) 如果找到了，删除它。

- 示例 1:
<img width="800" height="200" alt="image" src="https://github.com/user-attachments/assets/0b559923-72cc-4fe8-8adb-3384288e4169" />

- 输入：root = [5,3,6,2,4,null,7], key = 3
- 输出：[5,4,6,2,null,null,7]
- 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
  - 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
<img width="442" height="322" alt="image" src="https://github.com/user-attachments/assets/7678b558-42b2-4400-9e26-79e560e93fc9" />
  - 另一个正确答案是 [5,2,6,null,4,null,7]。

- 示例 2:
- 输入: root = [5,3,6,2,4,null,7], key = 0
- 输出: [5,3,6,2,4,null,7]
- 解释: 二叉树不包含值为 0 的节点

- 示例 3:
- 输入: root = [], key = 0
- 输出: []

---

- 第一种情况：没找到删除的节点，遍历到空节点直接返回了
- 找到删除的节点
1) 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
2) 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
3) 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
4) 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

---
`python语法：递归法`
```python
class Solution(object):
    def deleteNode(self, root, key):
        """
        :type root: Optional[TreeNode]
        :type key: int
        :rtype: Optional[TreeNode]
        """
        if(root == None):
            return root
        if(root.val == key):
            if(root.left == None and root.right == None):
                return None
            elif(root.left == None):
                return root.right # 返回root.right, 进行删除动作
            elif(root.right == None):
                return root.left # 返回root.left, 进行删除动作
            else:
                cur = root.right # 先记录当前要删除的节点的右节点
                while(cur.left != None):
                    cur = cur.left # 找到右节点最左边的左孩子
                cur.left = root.left # 将当前要删除的节点的左节点，接到右节点最左边的左孩子
                return root.right # 返回root.right, 进行删除动作

        # 没找到key，向左右子树寻找，并返回删除key的左右子树
        # 左右节点递归
        if(root.val > key):
            root.left = self.deleteNode(root.left, key)
        if(root.val < key):
            root.right = self.deleteNode(root.right, key)

        # 最终返回root根节点
        return root
```
---
`python语法：迭代法`
```python
class Solution(object):
    def deleteOneNode(self, target, key):
        # 先写特殊情况，遍历结束没找到节点，此时cur为None
        if(target == None):
            return target
        # 遍历中找到了节点的情况(cur != None)
        if(target.left == None and target.right == None): # (1) 左右孩子都为空
            return None
        if(target.left == None): # (2) 左节点为None，右孩子补位
            return target.right
        if(target.right == None): # (3) 右节点为None，左孩子补位
            return target.left
        else: # (4) 左右节点不为None
            cur_loc = target.right
            while(cur_loc.left != None):
                cur_loc = cur_loc.left
            cur_loc.left = target.left # 如动画所示，将当前要删除的节点的左节点，接到右节点最左边的左孩子
            return target.right


    def deleteNode(self, root, key):
        """
        :type root: Optional[TreeNode]
        :type key: int
        :rtype: Optional[TreeNode]
        """
        queue = []
        if(root == None): return root
        pre = None # pre记录cur的父节点
        cur = root
        # 利用while循环找到key符合的节点，以及其父节点
        while(cur != None):
            if(cur.val == key):
                break
            pre = cur # 记录cur的父节点
            if(cur.val < key):
                cur = cur.right
            elif(cur.val > key):
                cur = cur.left
        # 三种情况: 没找到(cur==None) / 找到,但需要删除根节点(pre==None) / 找到,树多个节点
        # (1) 先判断是否找到，这部分被写进函数本身了
        # (2) 找到，但需要删除根节点
        if(pre == None): return self.deleteOneNode(cur, key)
        # (3) 找到，树多节点：需要判断cur是pre的左节点还是右节点
        if(cur == pre.left):
            pre.left = self.deleteOneNode(cur, key)
        else:
            pre.right = self.deleteOneNode(cur, key)
        return root
```
