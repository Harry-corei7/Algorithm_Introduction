`难度: 中等`

给定一个二叉树的`根节点`root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

1) 示例 1：
- 输入：root = [1,2,3,null,5,null,4]
- 输出：[1,3,4]
- 解释；

<image src = "https://github.com/user-attachments/assets/db63bec3-1464-4635-9192-62e0d742d575" width = 600 height =300>

2) 示例 2：
- 输入：root = [1,2,3,4,null,null,null,5]
- 输出：[1,3,4,5]

<image src = "https://github.com/user-attachments/assets/afdd1a15-cead-4df0-a761-d5abe26f50f3" width = 600 height =300>

3) 示例 3：
- 输入：root = [1,null,3]
- 输出：[1,3]

4) 示例 4：
- 输入：root = []
- 输出：[]

---

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        // (1)创建res数组, queue单向队列
        List<Integer> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        // (2)特殊条件判断
        if(root == null)return res;
        // (3)遍历算法
        queue.offer(root);
        while(!queue.isEmpty()){
            int LeveSize = queue.size();
            // 每次将队列头的节点的值加入数组
            TreeNode node = queue.peek();
            res.add(node.val);
            // 每次循环将一层的节点去除,同时添加其右左节点进入队列
            for(int i = 0; i < LeveSize; i++){
                TreeNode node2 = queue.poll();
                if(node2.right != null)queue.offer(node2.right);
                if(node2.left != null)queue.offer(node2.left);
            }
        }
        return res;
    }
}
```
