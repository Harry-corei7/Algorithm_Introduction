给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

1) 示例 1：
<image src= "https://github.com/user-attachments/assets/4ececc26-291f-424a-9166-6e29f291932d" width = 400 height = 300>

- 输入：root = [3,9,20,null,null,15,7]
- 输出：2

2) 示例 2：
- 输入：root = [2,null,3,null,4,null,5,null,6]
- 输出：5

---
`java语法`
```java
class Solution {
    public int minDepth(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        int NodeNum = 0;
        if(root == null)return 0;
        queue.offer(root);
        boolean con = true;
        while(con){
            int LevelSize = queue.size();
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = queue.poll();
                // 找到叶子节点就结束循环
                if(node.left == null && node.right == null){
                    con = false;
                }else{ // 否则继续层序遍历整棵树
                    if(node.left != null)queue.offer(node.left);
                    if(node.right != null)queue.offer(node.right);
                }
            }
            NodeNum++;
        }
        return NodeNum;
    }
}
```
`python语法`
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minDepth(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        queue = [] # 设置队列用于遍历
        node_num = 0 # 用于计算层数(等同于最长路径节点数)
        if(root == None):
            return node_num
        queue.append(root)
        while(len(queue) != 0):
            level_size = len(queue)
            for i in range(level_size):
                node = queue[0]
                # 判断当前节点是不是叶子节点，是，就在这一层停止循环
                if(node.left == None and node.right == None):
                    # 弹空queue
                    while(len(queue) != 0):
                        queue.pop()
                    break
                if(node.left != None):
                    queue.append(node.left)
                if(node.right != None):
                    queue.append(node.right)
                queue.pop(0) 
            node_num += 1
        return node_num
```
