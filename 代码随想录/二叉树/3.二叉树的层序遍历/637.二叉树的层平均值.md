给定一个非空二叉树的根节点`root`, 以数组的形式返回每一层节点的平均值。与实际答案相差`10-5`以内的答案可以被接受。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/0357d824-5231-40cc-960f-0da4cf9aa6d4" width = 300 height = 300>

- 输入：root = [3,9,20,null,null,15,7]
- 输出：[3.00000,14.50000,11.00000]
- 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11]。

2) 示例 2:

<image src = "https://github.com/user-attachments/assets/148c785b-c905-4958-9d2c-3bec3ad42f3a" width = 300 height = 300>

- 输入：root = [3,9,20,15,7]
- 输出：[3.00000,14.50000,11.00000]

---
`java语法`
```java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();

        queue.offer(root);
        while(!queue.isEmpty()){
            int LevelSize = queue.size();
            Double num = 0.0;
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = queue.poll();
                num += node.val;
                if(node.left != null)queue.offer(node.left);
                if(node.right != null)queue.offer(node.right);
            }
            result.add(num/LevelSize);
        }
        return result;    
    }
}
```
`python语法`
```python
class Solution(object):
    def averageOfLevels(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[float]
        """
        queue = [] # 设置队列用于遍历
        res = [] # 设置答案数组
        if(root == None):
            return res
        queue.append(root)
        while(len(queue) != 0):
            level_size = len(queue)
            sum = 0
            for i in range(level_size):
                node = queue.pop(0)
                sum += node.val
                if(node.left != None): queue.append(node.left)
                if(node.right != None): queue.append(node.right)
            # python整数除法(除数被除数都是整数)默认向下取整
            mean_value = float(sum)/level_size # 所以需要float(sum)
            res.append(mean_value)
        return res
```
