给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

1) 示例 1：

<image src = "https://github.com/user-attachments/assets/d714f506-4497-4bf8-8eeb-08960415d43e" width = 400 height = 300>

- 输入：root = [3,9,20,null,null,15,7]
- 输出：2

2) 示例 2：

- 输入：root = [2,null,3,null,4,null,5,null,6]
- 输出：5

---
`java语法`
```java
class Solution {
    public int minDepth(TreeNode root) {
        Queue<TreeNode> que = new LinkedList<>();
        if(root == null)return 0;
        que.offer(root);
        int nodeNum = 0;
        boolean con = true;
        while(con){
            int LevelSize = que.size();
            // 层序遍历算法, LevelSize一层一层遍历
            for(int i = 0; i < LevelSize; i++){
                TreeNode node = que.poll();
                if(node.left == null && node.right == null){
                    // 找到叶子节点, 停止循环
                    con = false;
                }else{
                    // 没找到叶子节点, 继续遍历
                    if(node.left != null)que.offer(node.left);
                    if(node.right !=  null)que.offer(node.right);
                }
            }
            nodeNum++;
        }
        return nodeNum;
    }
}
```
`python语法`
```python
class Solution(object):
    def minDepth(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        queue = [] # 设置队列用于遍历
        node_num = 0 # 用于计算层数(等同于最长路径节点数)
        if(root == None):
            return node_num
        queue.append(root)
        while(len(queue) != 0):
            level_size = len(queue)
            node_num += 1
            for i in range(level_size):
                node = queue.pop(0)
                # 判断当前节点是不是叶子节点，是，就在这一层停止循环
                if(node.left == None and node.right == None):
                    while(len(queue) != 0): queue.pop(0) # 先弹空节点，以便结束最外层循环
                    break # 在这里结束循环
                # 不是叶子节点，该节点子节点入队列
                if(node.left != None):queue.append(node.left)
                if(node.right != None):queue.append(node.right)
        return node_num
```
