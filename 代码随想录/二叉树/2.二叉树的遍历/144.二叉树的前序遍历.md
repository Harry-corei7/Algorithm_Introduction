给你二叉树的根节点 root ，返回它节点值的`前序`遍历。

1) 示例 1：
- 输入：root = [1,null,2,3]
- 输出：[1,2,3]
- 解释：

<img src ="https://github.com/user-attachments/assets/12725d79-c336-4d6d-a903-32bdfe21c21e" width = "150" height = "150"> 

2) 示例 2：
- 输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]
- 输出：[1,2,4,5,6,7,3,8,9]
- 解释：

<img src = "https://github.com/user-attachments/assets/7b77d0e1-6569-4310-986b-fedc74485d50" width = "200" height = "150">

3) 示例 3：
- 输入：root = []
- 输出：[]

4) 示例 4：
- 输入：root = [1]
- 输出：[1]

---

`1.递归遍历`

```java
// 前序遍历·递归·LC144_二叉树的前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        preorder(root, result);
        return result;
    }

    public void preorder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preorder(root.left, result);
        preorder(root.right, result);
    }
}
```
`二叉树案例:`
```
        1
       / \
      2   3
     / \
    4   5
```
`遍历流程-图示:`
```
preorder(1)
│  result.add(1) → [1]
│
├─ preorder(2)
│   │  result.add(2) → [1, 2]
│   │
│   ├─ preorder(4)
│   │   │  result.add(4) → [1, 2, 4]
│   │   ├─ preorder(null) → return
│   │   └─ preorder(null) → return
│   │
│   └─ preorder(5)
│       │  result.add(5) → [1, 2, 4, 5]
│       ├─ preorder(null) → return
│       └─ preorder(null) → return
│
└─ preorder(3)
    │  result.add(3) → [1, 2, 4, 5, 3]
    ├─ preorder(null) → return
    └─ preorder(null) → return
```

---

`2.迭代遍历`

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        // (1)构建res数组和stack栈
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        // (2)特殊情况判断
        if(root == null){
            return res;
        }
        // (3)先push根节点
        stack.push(root);
        while(!stack.empty()){
            // 节点val入数组
            TreeNode node = stack.pop();
            res.add(node.val);
            // 右节点先入栈, 后出
            if(node.right != null){
                stack.push(node.right);
            }
            // 左节点后入栈, 先出
            if(node.left != null){
                stack.push(node.left);
            }
        }
        return res;
    }
}

```

---

`3.二叉树遍历统一写法(更符合逻辑)`

`java语法`
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        // (1)构建res数组和stack栈
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        // (2)特殊条件判断
        if(root == null){
            return res;
        }
        // (3)遍历算法
        stack.push(root);
        while(!stack.isEmpty()){
            if(stack.peek() != null){
                TreeNode node = stack.pop(); // 防止重复操作"当前"根节点
                // 前序遍历: 根左右, 入栈顺序: 右左根
                if(node.right != null)stack.push(node.right); // 添加右节点(空节点不入栈)
                if(node.left != null)stack.push(node.left); // 添加左节点(空节点不入栈)
                stack.push(node); // 添加"当前"根节点
                stack.push(null); // 添加null
            } else{
                stack.pop(); // 退出空节点null
                TreeNode node = stack.pop(); // 处理空节点后的节点
                res.add(node.val);
            }
        }
        return res;
    }
}
```
`python语法`
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[int]
        """
        res = [] # 设置结果列表
        stack = [] # 设置栈来进行递归
        if(root == None): # 特殊情况处理，根节点为空
            return res
        stack.append(root)
        while(len(stack) != 0):
            if(stack[-1] != None):
                node = stack.pop() # 弹出栈顶节点，作为"当前"根节点
                # 前序遍历：根左右，所以入栈：右左根
                if(node.right != None):
                    stack.append(node.right)
                if(node.left != None):
                    stack.append(node.left)
                stack.append(node)
                stack.append(None) # 用None作为标记，表示该节点的右节点，左节点已经入栈
            else:
                stack.pop() # 弹出None标记
                node = stack.pop() # 弹出节点
                res.append(node.val) # 访问节点
        return res
```
