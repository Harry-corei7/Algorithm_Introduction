给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

1) 示例 1：
- 输入：root = [1,null,2,3]
- 输出：[3,2,1]

解释：

<img src = "https://github.com/user-attachments/assets/9cd5bbf9-0b54-4e0a-96c3-437d44fc60ec" width = "150" height = "135">

2) 示例 2：
- 输入：root = [1,2,3,4,5,null,8,null,null,6,7,9]
- 输出：[4,6,7,5,2,9,8,3,1]

解释：

<img src = "https://github.com/user-attachments/assets/fd294c51-549a-4cf0-b094-345174f9657b" width = "150" height = "135">

3) 示例 3：
- 输入：root = []
- 输出：[]

4) 示例 4：
- 输入：root = [1]
- 输出：[1]

---

`1.递归遍历`

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }
    public void postorder(TreeNode node, List<Integer> res){
        if(node == null){
            return;
        }
        postorder(node.left, res);
        postorder(node.right, res);
        res.add(node.val);
    }
}
```

`二叉树案例`

```
        1
       / \
      2   3
     / \
    4   5
```

`遍历流程-图示`

```
preorder(1)
│
├─ preorder(2)
│   
│   ├─ preorder(4)  
│   │   ├─ preorder(null) → return
│   │   └─ preorder(null) → return
│   │   │  result.add(4) → [4]
│   │
│   └─ preorder(5)
│       ├─ preorder(null) → return
│       └─ preorder(null) → return
│       │  result.add(5) → [4, 5]
│   │
│   │  result.add(2) → [4, 5, 2]
│
└─ preorder(3)
│   
│   ├─ preorder(null) → return
│   └─ preorder(null) → return
│   │  result.add(3) → [4, 5, 2, 3]
│
│  result.add(1) → [4, 5, 2, 3, 1]
```

---

`2.迭代遍历`

```java
// 与前序遍历类似, 不过是中-右-左, 最后利用Collection.reverse(res)调换顺序
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if(root == null){
            return res;
        }
        stack.push(root);

        while(!stack.empty()){
            TreeNode node = stack.pop();
            res.add(node.val);
            if(node.left != null){
                stack.push(node.left);
            }
            if(node.right != null){
                stack.push(node.right);
            }
        }
        // 中-右-左
        // 利用collection反转res
        Collections.reverse(res);
        return res;
    }
}
```

---

`3.二叉树遍历统一方法`

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        // (1) 创建res数组和stack栈
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        // (2) 特殊条件判断
        if(root == null)return res;
        // (3) 遍历算法
        stack.push(root);
        while(!stack.isEmpty()){
            if(stack.peek() != null){
                TreeNode node = stack.pop(); // 防止重复操作"当前"根节点
                // 后序遍历: 左右根, 入栈顺序: 根右左
                stack.push(node);  // 添加"当前"根节点
                stack.push(null);
                if(node.right != null)stack.push(node.right); // 添加右节点(空节点不入栈)
                if(node.left != null)stack.push(node.left); // 添加左节点(空节点不入栈)
            } else{
                stack.pop(); // 退出空节点
                TreeNode node = stack.pop(); // 处理空节点后的节点
                res.add(node.val);
            }
        }
        return res;
    }
}
```
