给定一个二叉树的根节点 root ，返回它的`中序`遍历。

1) 示例 1：

<img src = "https://github.com/user-attachments/assets/6fcd660a-ced5-434a-a0c0-53a82dce0aa4" width = "150" height = "135">

- 输入：root = [1,null,2,3]
- 输出：[1,3,2]

2) 示例 2：
- 输入：root = []
- 输出：[]

3) 示例 3：
- 输入：root = [1]
- 输出：[1]

---

`1.递归遍历`

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        midorder(root, res);
        return res;
    }
    public void midorder(TreeNode node, List<Integer> res){
        if(node == null){
            return;
        }
        midorder(node.left, res);
        res.add(node.val);
        midorder(node.right, res);
    }
}
```

`二叉树案例`

```
        1
       / \
      2   3
     / \
    4   5
```

`遍历流程-图示`

```
preorder(1)
│  
├─ preorder(2)  
│   │
│   ├─ preorder(4) 
│   │   ├─ preorder(null) → return
│   │   │  result.add(4) → [4]
│   │   └─ preorder(null) → return
│   │
│   │  result.add(2) → [4, 2]
│   │
│   └─ preorder(5)
│       ├─ preorder(null) → return
│       │  result.add(5) → [4, 2, 5]
│       └─ preorder(null) → return
│  
│result.add(1) → [4, 2, 5, 1]
│ 
└─ preorder(3)
    ├─ preorder(null) → return
    │  result.add(3) → [4, 2, 5, 1, 3]
    └─ preorder(null) → return

```

---

`2.迭代遍历`

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        
        // (1) 特殊情况判断
        if(root == null){
            return res;
        }
        // (2) 与前后序不同的地方,中序需要一个指针,以便从root到达最左端left
        TreeNode cur = root;
        while(cur != null || !stack.isEmpty()){
            if(cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            // 当cur==null时, node出栈, cur指向右节点
            else{
                cur = stack.pop();
                res.add(cur.val);
                cur = cur.right;
            }
        } 
        return res;
    }
}
```

---

`3.二叉树统一遍历方法`

`java语法`
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        // (1) 创建res数组和stack栈
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        // (2) 特殊情况判断
        if(root ==  null)return res;
        // (3) 遍历算法
        stack.push(root);
        while(!stack.isEmpty()){
            if(stack.peek() != null){
                TreeNode node = stack.pop();
                // 中序遍历: 左根右, 入栈顺序: 右根左
                if(node.right != null)stack.push(node.right); // 添加右节点(空节点不入栈)
                stack.push(node); // 添加"当前"根节点
                stack.push(null);
                if(node.left != null)stack.push(node.left); // 添加左节点(空节点不入栈)
            }else{
                stack.pop(); // 退出空节点
                TreeNode node = stack.pop(); // 处理空节点后的那个节点
                res.add(node.val);
            }
        }
        return res;
    }
}
```
`python语法`
```python
res = [] # 设置结果列表
        stack = [] # 设置栈来递归
        if(root ==  None): # 特殊情况处理，根节点为空
            return res
        stack.append(root)
        while(len(stack) != 0):
            if(stack[-1] != None):
                node = stack.pop()
                # 中序遍历: 左中右，因此入栈: 右中左
                if(node.right != None):
                    stack.append(node.right) # 添加右节点(空节点不入栈)
                stack.append(node) # 添加"当前"根节点
                stack.append(None) # 用None作为标记，表示该节点的右节点，左节点已经入栈
                if(node.left != None):
                    stack.append(node.left) # 添加左节点(空节点不入栈)
            else:
                stack.pop() # 弹出None标记
                node = stack.pop() # 弹出节点
                res.append(node.val) # 访问节点
        return res
```
