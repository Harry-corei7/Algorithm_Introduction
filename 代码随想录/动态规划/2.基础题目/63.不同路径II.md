`难度：中等`

- 给定一个`m x n`的整数数组`grid`。
- 一个机器人初始位于 左上角（即`grid[0][0]`）。机器人尝试移动到 右下角（即`grid[m - 1][n - 1]`）。
- 机器人每次只能向下或者向右移动一步。

- 示例 1：
  - 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
  - 输出：2
  - 解释：
    - 3x3 网格的正中间有一个障碍物。
    - 从左上角到右下角一共有 2 条不同的路径：
    - 向右 -> 向右 -> 向下 -> 向下
    - 向下 -> 向下 -> 向右 -> 向右

<img width="448" height="246" alt="image" src="https://github.com/user-attachments/assets/0e262a5d-0b95-4452-ae93-e0d6ef92ac54" />

- 示例 2：
  - 输入：obstacleGrid = [[0,1],[0,0]]
  - 输出：1

<img width="448" height="170" alt="image" src="https://github.com/user-attachments/assets/6981c3b8-a1bc-4efa-aa3f-b3df170bc636" />

---
`python语法：动态规划(个人理解版)`
```python
class Solution(object):
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        # (1) 确定dp数组及下标意义 (2) 确定递推公式 
        dp = [[0] * len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]
        # (3) dp数组初始化
        if(obstacleGrid[0][0] == 1): # 特殊情况，障碍物在起点
            return 0
        # 起点无障碍物，起点dp值为1
        dp[0][0] = 1

        # 横向边界
        for i in range(1, len(obstacleGrid[0])):
            if(obstacleGrid[0][i] == 1): # 遇到障碍物
                dp[0][i] = 0
            else: 
                dp[0][i] = dp[0][i-1] # 递推横向边界
        # 纵向边界
        for j in range(1, len(obstacleGrid)):
            if(obstacleGrid[j][0] == 1): # 遇到障碍物
                dp[j][0] = 0
            else:
                dp[j][0] = dp[j-1][0] # 递推纵向边界
        
        # (4) 确定递推顺序
        for i in range(1, len(obstacleGrid[0])):
            for j in range(1, len(obstacleGrid)):
                if(obstacleGrid[j][i] == 1):
                    dp[j][i] = 0
                else:
                    dp[j][i] = dp[j-1][i] + dp[j][i-1]
        return dp[len(obstacleGrid)-1][len(obstacleGrid[0])-1]
```
