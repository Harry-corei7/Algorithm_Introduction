- 给你一个整数数组`cost`，其中`cost[i]`是从楼梯第`i`个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
- 你可以选择从下标为`0`或下标为`1`的台阶开始爬楼梯。
- 请你计算并返回达到楼梯顶部的最低花费。

- 示例 1：
    - 输入：cost = [10,15,20]
    - 输出：15
    - 解释：你将从下标为 1 的台阶开始。
        - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
        - 总花费为 15 。

- 示例 2：
    - 输入：cost = [1,100,1,1,1,100,1,1,100,1]
    - 输出：6
    - 解释：你将从下标为 0 的台阶开始。
        - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
        - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
        - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
        - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
        - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
        - 支付 1 ，向上爬一个台阶，到达楼梯顶部。
        - 总花费为 6 。
---
> 动态规划思路

### (1) 确定dp数组以及下标的含义

- 使用动态规划，就要有一个数组来记录状态，本题只需要一个`一维数组dp[i]`就可以了。
- **dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。**

### (2) 确定递推公式

- 可以有`两个途径`得到`dp[i]`，一个是`dp[i-1]`，一个是`dp[i-2]`。
    - `dp[i - 1]`跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。
    - `dp[i - 2]`跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。
- **一定是选最小的**，所以`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`

### (3) dp数组如何初始化

- 看一下递归公式，`dp[i]`由`dp[i - 1]`，`dp[i - 2]`推出
- 既然初始化所有的`dp[i]`是不可能的，那么只初始化`dp[0]`和`dp[1]`就够了，其他的最终都是`dp[0]`和`dp[1]`推出。

### (4) 确定遍历顺序

- 本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。
- 因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。

### (5) 举例推导dp数组

- 拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：

<img width="1292" height="432" alt="image" src="https://github.com/user-attachments/assets/2c8d6f10-f4fe-4010-b3bf-f4d50f894f76" />

---
`python语法：动态规划`
```python
class Solution(object):
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        dp = []
        dp.append(0) # 初始化下标0的阶梯
        dp.append(0) # 初始化下标1的阶梯
        for i in range(2, len(cost)+1):
            dp.append(min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])) # 开始递推
        return dp[-1]
```
