`难度：中等`

- 给你一个整数`n`，求恰由`n`个节点组成且节点值从`1`到`n`互不相同的`二叉搜索树`有多少种？
- 返回满足题意的二叉搜索树的种数。

- 示例 1：
  - 输入：n = 3
  - 输出：5

<img width="900" height="220" alt="image" src="https://github.com/user-attachments/assets/30a0db54-8b88-4650-9f68-4aa861db727b" />

- 示例 2：
  - 输入：n = 1
  - 输出：1

---
> 动态规划思路

- 了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：

<img width="435" height="220" alt="image" src="https://github.com/user-attachments/assets/6a11d4fb-847d-425f-b78a-a98d4e37aa8e" />

- n为1的时候有一棵树，n为2有两棵树，这个是很直观的。

<img width="850" height="300" alt="image" src="https://github.com/user-attachments/assets/585474ab-5a3b-46d4-96c8-d64deef741af" />

- 当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！
- 当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！
- 发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

- dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
  - 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
  - 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
  - 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

- 有2个元素的搜索树数量就是dp[2]。
- 有1个元素的搜索树数量就是dp[1]。
- 有0个元素的搜索树数量就是dp[0]。
- 所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

- 如图所示：

<img width="1005" height="555" alt="image" src="https://github.com/user-attachments/assets/0b2003dd-2007-46f3-bbf9-6d629cf9b29e" />


---
`python语法：动态规划`
```python
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0]*(n+1)
        if(n < 3): return n
        dp[0] = 1 # 空节点也是一颗二叉搜索树
        dp[1] = 1
        dp[2] = 2
        for k in range(3, n+1):
            # 从3开始进行填充
            for i in range(0, k):
                j = k-1-i
                dp[k] += dp[i]*dp[j] # 核心：递推公式
        return dp[-1]
```
