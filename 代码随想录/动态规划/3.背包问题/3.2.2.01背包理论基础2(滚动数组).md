### 思路

- 在`01背包理论基础1`中，我们是用`dp二维数组`来讲解`01背包问题`
- 在`01背包理论基础2`中，我们来讲解一下`dp滚动数组`

- 接下来还是用如下这个例子来进行讲解
  - 背包最大重量为4。
  - 物品如下表格所示：
  - 问背包能背的物品最大价值是多少？

|   |重量|价值|
|---|---|---|
|物品0 |1 |15 |
|物品1 |3 |20 |
|物品2 |4 |30 |

---

### 一维dp数组（滚动数组）

- 在使用`二维数组`的时候，`递推公式`：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`
- 可以发现如果把`dp[i - 1]`那一层**拷贝**到`dp[i]`之后：
  - 表达式其实完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`
  1) 先复制[i-1]那一行的数值
  2) `递推公式`中的[i-1]全部更新为[i]

- **与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了**
  - 只用`dp[j]`，把[i]去掉
  - **一维数组，也可以理解是一个滚动数组，每一次遍历都在更新。**

- 读到这里估计大家都忘了 `dp[i][j]`里的`i`和`j`表达的是什么了，`i`是物品，`j`是背包容量。
  - `dp[i][j]`表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。
---

### 动规五部曲分析如下：

> (1) 确定dp数组的定义
- 在`一维dp数组`中，`dp[j]`表示：容量为`j`的背包，所背的物品价值可以最大为`dp[j]`。


> (2) 一维dp数组的递推公式
- 二维dp数组的递推公式为：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`
- 一维dp数组的递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`
  - 一维dp数组，其实就上上一层 dp[i-1] 这一层 拷贝的 dp[i]来。
  - 所以在`上面递推公式的基础上`，**去掉i这个维度**就好。
- 以下为分析：
  - (1) `dp[j]`为`容量为j`的背包所背的最大价值。
  - (2) `dp[j]`可以通过`dp[j - weight[i]]`推导出来，`dp[j - weight[i]]`表示容量为`j - weight[i]`的背包所背的最大价值。
  - (3) `dp[j - weight[i]] + value[i]`表示`容量为 [j - 物品i重量]`的背包**加上**`物品i`的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）
  - (4) 此时dp[j]有两个选择，
    - 一个是取自己`dp[j]`相当于**二维dp数组中的dp[i-1][j]**，即`不放物品i`，
    - 一个是取`dp[j - weight[i]] + value[i]`，即`放物品i`，指定是取最大的，毕竟是求最大价值，


> (3) 一维dp数组如何初始化
- **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**
- 首先，`dp[0]`就应该是`0`，因为`背包容量为0`所背的物品的最大价值就是`0`。
- 其次，其他下标应该初始化多少呢？看一下递归公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`,非0下标都初始化为0就可以了。
- **这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。**


> (4) 一维dp数组遍历顺序
- 遍历代码如下所示:
```python
for i in range(len(weight)): # 遍历所有物品
    for j in range(bagweight, weight[i]-1, -1): # 遍历背包容量，从后往前遍历，到下标weight[i]停止，因为这是可能装下weight[i]物品的最后一栏
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```
- 注意：倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！
  - 因为背包容量每一栏的状态(值)是由`前j-weight[i]个背包容量的状态(值)`递推出来得到的
  - 所以`从后往前遍历`，**每次取得状态不会和之前取得状态重合**，这样每种物品就只取一次了。


> (5) 举例推导dp数组
- 一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

<img width="890" height="482" alt="image" src="https://github.com/user-attachments/assets/7e5fe84c-c5d3-41ef-b8ff-60e5dddf12fd" />
