- leetcode上没有纯`01背包`的问题，都是`01背包应用方面`的题目，也就是需要转化为`01背包问题`。

- 所以我先通过纯`01背包问题`，把`01背包原理`讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为`01背包问题`了。

- 之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！
---

### 01 背包

- 一个典型的背包问题
  - 有`n`件物品和一个最多能背重量为`w`的背包。
  - 第`i`件物品的重量是`weight[i]`，得到的价值是`value[i]`。
  - **每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

- 这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道`暴力的解法`应该怎么解了。
  - 这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？
  - 每一件物品其实只有两个状态，取或者不取，所以可以使用`回溯法`搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。

- **所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**

- 在下面的讲解中，我举一个例子：
  - 背包最大重量为4。
  - 物品为：

|   |重量|价值|
|----|---|---|
|物品0|1 |15 |
|物品1|3 |20 |
|物品2|4 |30 |

- 问背包能背的物品最大价值是多少？
- 以下讲解和图示中出现的数字都是以这个例子为例。
---

### 二维dp数组01背包
- 依然动规五部曲分析一波。

> 1. 确定dp数组以及下标的含义
- 我们需要使用二维数组，为什么呢？
  - 因为有两个维度需要分别表示：`物品`和`背包容量`
  - 如图，二维数组为 dp[i][j]。

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/6c3b1620-8a55-439b-957b-42da72bea394" />

- 那么这里`i`、`j`、`dp[i][j]`分别表示什么呢？
  - i 来表示物品、j表示背包容量。

- 我们先看把物品0 放入背包的情况：
  - 背包容量为0，放不下物品0，此时背包里的价值为0。
  - 背包容量为1，可以放下物品0，此时背包里的价值为15.
  - 背包容量为2，依然可以放下物品0 （注意 01背包里物品只有一个），此时背包里的价值为15。

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/7291aec3-4531-4929-8b92-f2fbd4acaf76" />

- 再看把物品1 放入背包：
  - 背包容量为 0，放不下物品0 或者物品1，此时背包里的价值为0。
  - 背包容量为 1，只能放下物品0，背包里的价值为15。
  - 背包容量为 2，只能放下物品0，背包里的价值为15。
  - 背包容量为 3，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放物品1 或者 物品0，物品1价值更大，背包里的价值为20。
  - 背包容量为 4，上一行同一状态，背包只能放物品0，这次也可以选择物品1了，背包可以放下物品0 和 物品1，背包价值为35。

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/7b4d807d-d49f-4f1e-a623-0df859ea9b2b" />


- 上图中，我们看`dp[1][4]`表示什么意思呢。
  - 任取`物品0`，`物品1`放进容量为4的背包里，最大价值是 dp[1][4]。
- 通过这个举例，我们来进一步明确`dp数组`的含义。
  - **即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。**
  - **要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的**
---

> 2. 确定递推公式

- 这里在把基本信息给出来：
  - 背包最大重量为4。
  - 物品为：

|   |重量|价值|
|----|---|---|
|物品0|1 |15 |
|物品1|3 |20 |
|物品2|4 |30 |

- 对于递推公式，首先我们要明确有哪些方向可以推导出 dp[i][j]。
- 这里我们dp[1][4]的状态来举例：
  - 放物品1
  - 还是不放物品1
- 如果不放物品1， 那么背包的价值应该是 dp[0][4] 即 容量为4的背包，只放物品0的情况。
- 推导方向如图：

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/93614535-242e-4f3e-a2dc-34a4d8c170e0" />

- 如果放物品1，**那么背包要先留出物品1的容量**，目前容量是4，物品1 的容量（就是物品1的重量）为3，此时背包剩下容量为1。
- 容量为1，只考虑放物品0 的最大价值是 dp[0][1]，这个值我们之前就计算过。
- 所以 放物品1 的情况 = dp[0][1] + 物品1 的价值，推导方向如图：

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/a02c0a66-124a-48f5-bff4-2cde2c6f5d38" />

- 两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值）
  - `dp[1][4] = max(dp[0][4], dp[0][1] + 物品1 的价值)`
- 以上过程，抽象化如下：
  - `不放物品i`：
    - 背包容量为`j`，里面不放`物品i`的最大价值是`dp[i - 1][j]`。
  - `放物品i`：
    - 背包空出物品i的容量后，背包容量为`j - weight[i]`
    - `dp[i - 1][j - weight[i]]`为背包容量为`j - weight[i]`且不放物品i的最大价值
    - 那么`dp[i - 1][j - weight[i]] + value[i]（物品i的价值）`，就是背包放物品i得到的最大价值

- **递归公式**：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`
---

> 3. dp数组如何初始化

- **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**

- 首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0，如图：

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/c840aa52-c4f6-4748-9491-a28d2e7cd41b" />

- 在看其他情况：
- `状态转移方程`: `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`
  - 可以看出`i`是由`i-1`推导出来，那么`i`为0的时候就一定要初始化。
- dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。
  - 那么很明显当`j < weight[0]`的时候，`dp[0][j]`应该是0，因为背包容量比编号0的物品重量还小。
  - 当`j >= weight[0]`时，`dp[0][j]`应该是`value[0]`，因为背包容量放足够放编号0物品。
- 代码初始化如下：
```python
for i in range(0, len(weight)):   # 将dp第一列(背包重量j=0)的所装物品最大可能价值，全部初始化=0，因为装不了任何东西
    dp[i][0] = 0
# 正序遍历
for j in range(weight[0], bagweight+1): # 将dp第一行(只考虑装物品0)，在背包能装下物品0开始，到最后行末，全部初始化为value[0]
    dp[0][j] = value[0]
```
- 此时dp数组初始化情况如图所示：

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/e253ccc5-10d9-4b07-9782-4493840f49bf" />

- dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？
  - 其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了
  - 那么其他下标初始为什么数值都可以，因为会被覆盖，统一初始为0，更方便一些，如图：

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/d0ba61c0-a474-4ad7-9154-ed9f5422e324" />

- **最后初始化代码如下所示**：
```python
# 初始化 dp
dp = [[0] * (bagweight + 1) for _ in range(len(weight))]

for j in range(weight[0], bagweight + 1): # 将dp第一行(只考虑装物品0)，在背包能装下物品0开始，到最后行末，全部初始化为value[0]
    dp[0][j] = value[0] 
```
---

> 4. 确定遍历顺序

- 在如下图中，可以看出，有两个遍历的维度：`物品`与`背包重量`

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/6a4881a7-a401-4dcb-98b8-a7e9ffca43ea" />

- 那么问题来了，先遍历 物品还是先遍历背包重量呢？**其实都可以！！ 但是先遍历物品更好理解。**
- 那么我先给出先遍历物品，然后遍历背包重量的代码如下所示：
```python
for i in range(1, len(weight)): # 遍历物品
    for j in range(0, bagweight): # 遍历背包容量
        if(j < weight[i]):
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[1]] + value[i])
```

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/71806c75-2964-45a4-90c5-0b567ce05d8c" />

- 大家可以看出，虽然`两个for循环`(先遍历物品/先遍历背包容量)遍历的次序不同，但是`dp[i][j]`所需要的数据就是左上角，根本不影响`dp[i][j]`公式的推导！
- 但`先遍历物品再遍历背包`这个顺序更好理解。
- 其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了。
---

> 5. 举例推导dp数组
- 来看一下对应的dp数组的数值，如图：

<img width="682" height="360" alt="image" src="https://github.com/user-attachments/assets/9c347a20-3e2f-4e1f-9943-92154dd8f01c" />

- 最终结果就是dp[2][4]。
- 建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。
- 做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！
