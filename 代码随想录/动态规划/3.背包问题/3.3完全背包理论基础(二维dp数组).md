## 完全背包理论基础-二维DP数组

### 完全背包

- 有`N`件物品和一个最多能背重量为`W`的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]`。
- `每件物品都有无限个（也就是可以放入背包多次）`，求解将哪些物品装入背包里物品价值总和最大。
- **完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。**
---

### 1. 确定dp数组以及下标的含义

- **dp[i][j] 表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。**


### 2. 确定递推公式

- 这里在把基本信息给出来：

| |重量|价值|
|---|---|---|
|物品0|1 |15 |
|物品1|3 |20 |
|物品2|4 |30 |

- 对于递推公式，首先我们要明确有哪些方向可以推导出`dp[i][j]`。
- 这里依然拿`dp[1][4]`的状态来举例：
  - 求取`dp[1][4]`有两种情况：
    - 放物品1
    - 还是不放物品1
- `情况(1)`: 如果不放`物品1`， 那么背包的价值应该是`dp[0][4]`，即`容量为4的背包`，只放`物品0`的情况。
- 推导方向如图：

<img width="612" height="310" alt="image" src="https://github.com/user-attachments/assets/9155c088-cece-4ac6-a54c-51c4274bc520" />

- `情况(2)`: 如果放物品1，**那么背包要先留出物品1的容量**，目前容量是`4`，`物品1`的容量（就是物品1的重量）为3，此时背包剩下容量为1。
  - 在完全背包中，**物品是可以放无限个**，所以 即使空出物品1空间重量，那背包中也可能还有物品1
  - 所以此时我们依然考虑放`物品0`和`物品1`的最大价值即：`dp[1][1]`，**而不是**`dp[0][1]`，**注意，这里和01背包不一样**
  - 所以`放物品1`的情况 = `dp[1][1] + 物品1`的价值，推导方向如图：

<img width="618" height="324" alt="image" src="https://github.com/user-attachments/assets/0c4b1fe6-4487-4ca2-b2b4-14397ea2715c" />

- **注意上图和01背包理论基础（二维数组）中的区别，对于理解完全背包很重要**

- `两种情况`，分别是放`物品1`和`不放物品1`，我们要取**最大值**（毕竟求的是最大价值）
- `递推公式`：`dp[1][4] = max(dp[0][4], dp[1][1] + 物品1 的价值)`

- **总结如下：**
  - `不放物品i`：背包容量为`j`，里面不放`物品i`的最大价值是`dp[i - 1][j]`。
  - `放物品i`：
    - 背包空出`物品i`的容量后，背包容量为`j - weight[i]`，
    - 背包容量为`j - weight[i]`且不放物品i的情况下，最大价值为`dp[i][j - weight[i]]`
    - 那么`dp[i][j - weight[i]] + value[i]（物品i的价值）`，就是背包放`物品i`得到的最大价值
  - `递推公式`：`dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i])`
---

### 3. dp数组如何初始化

- **关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。**
- 首先，从`dp[i][j]`的定义出发，如果背包容量`j`为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。如图：

<img width="852" height="498" alt="image" src="https://github.com/user-attachments/assets/83f9f12d-4295-40b7-a616-2f794c25d219" />

- 其次，状态转移方程`dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])`，可以看出有一个`方向i`是由`i-1`推导出来，那么`i为0`的时候就一定要初始化。
  - `dp[0][j]`，即：存放编号0的物品的时候，各个容量的背包所能存放的最大价值。
  - 那么很明显当`j < weight[0]`的时候，`dp[0][j]`应该是`0`，因为背包容量比编号0的物品重量还小。
  - 当`j >= weight[0]`时，`dp[0][j]`如果能放下`weight[0]`的话，**就一直装，每一种物品有无限个。**
- 代码如下所示：
```python
for i in range(0, len(weight)):
    dp[i][0] = 0
# 正序遍历，如果能放下就一直装物品0
for j in range(weight[0], bagweight + 1):
    dp[0][j] = dp[0][j - weight[0]] + value[0] # 相较01背包：dp[0][j] = value[0]，这里是累加
```

- 此时dp数组初始化情况如图所示：

<img width="730" height="412" alt="image" src="https://github.com/user-attachments/assets/6d4a806f-6225-4a86-bb0d-4d5b7402376a" />

- **个人理解，这里并没有讲清楚第一行[0][0]到[0][weight[0]]之间的数值的初始化，这一段应该都初始化为0**
- `代码随想录的找补`：可以看出`dp[i][j]`是由`上方`和`左方数值`推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。
- 但只不过一开始就统一把dp数组统一初始为0，更方便一些。

- 最后最终初始化代码如下
```python
# 将dp数组全初始化为0
dp = [[0]*(bagweight + 1) for _ in range(len(weight))]
# 将物品0的第一行进行初始化
for j in range(weight[0], bagweight+1):
    dp[0][j] = dp[0][j - weight[0]] + value[0]
```
---

### 4. 确定遍历顺序

- 这里只举一种便于理解的遍历顺序
- 先遍历物品再遍历背包，代码如下所示：
```python
for i in range(1, len(weight)):
    for j in range(1, bagweight + 1):
        if(j < weight[i]): # 与01背包一样
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i - weight[0]][j] + value[0])
```

### 5. 举例推导dp数组
- 以本篇举例数据为例，填满了dp二维数组如图：

<img width="630" height="332" alt="image" src="https://github.com/user-attachments/assets/d14cbd5c-f4f1-4531-89a9-72e2b705f852" />
