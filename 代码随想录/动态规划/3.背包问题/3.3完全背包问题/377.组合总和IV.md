`难度：中等`

- 给你一个由**不同**整数组成的数组`nums`，和一个目标整数`target`。请你从`nums`中找出并返回总和为`target`的元素**排列**的个数。
- 题目数据保证答案符合`32`位整数范围。

- 示例 1：
    - 输入：nums = [1,2,3], target = 4
    - 输出：7
    - 解释：
        - 所有可能的排列方式为：
        - (1, 1, 1, 1)
        - (1, 1, 2)
        - (1, 2, 1)
        - (1, 3)
        - (2, 1, 1)
        - (2, 2)
        - (3, 1)
    - 请注意，顺序不同的序列被视作不同的排列方式。

- 示例 2：
    - 输入：nums = [9], target = 3
    - 输出：0
---
> 动态规划：完全背包_一维dp数组(解决排列问题)

- 首先，完全背包策略，一维dp数组，可以解决排列问题
    - `一维dp数组：外层遍历物品，内层遍历容量`：可以解决组合问题，无法解决排列问题
    - `一维dp数组：外层遍历容量，内层遍历物品`：可以解决排列问题

- 要理解为什么`外层遍历容量，内层遍历物品`可以解决**排列问题**，可以观察下面的图示
    -  以`示例 1`问题的数据举例
    -  只有`外层遍历容量，内层遍历物品`才可以累计`{1,3}`和`{3,1}`
    -  因为`外层遍历物品，内层遍历容量`，只会累计`{1,3}`

|外层j容量遍历|j = 0|j = 1|j = 2|j = 3|j = 4|内层物品i遍历|
|---|---|---|---|---|---|---|
|数组在j=0的情况:|1 |0 |0 |0 |0 |无物品遍历 |
|数组在j=1的情况:|1 |+1 |0 |0 |0 |物品i=0(1)遍历 |
|数组在j=2的情况:|1 |1 |+1+1 |0 |0 |物品i=0,1(1,2)遍历 |
|数组在j=3的情况:|1 |1  |2 |+2+1+1 |0 |物品i=0,1,2(1,2,3)遍历
|数组在j=4的情况:|1 |1  |2  |4 |+4+2+1 |物品i=0,1,2(1,2,3)遍历 |

- **举例说明：**

- 在`外层j=2遍历的那一行`中
    - `j=2那一列`的第1个`+1`是遍历`物品0`，是+=`j=1那一列`的值，可以看作{1，1}(两张1，和为2)
    - `j=2那一列`的第2个`+1`是遍历`物品1`，是+=`j=0那一列`的值，可以看作{2}(一张2，和为2)
- 在`外层j=3遍历的那一行`中
    - `j=3那一列`的第1个`+2`是遍历`物品0`，是+=`j=2那一列`的值，可以看作{1，1，1}(三张1，和为3)，{2，1}(一张2一张1，和为3)
    - `j=3那一列`的第2个`+1`是遍历`物品1`，是+=`j=1那一列`的值，可以看作{1，2}(一张1一张2，和为3)
    - `j=3那一列`的第3个`+1`是遍历`物品2`，是+=`j=0那一列`的值，可以看作{3}(一张3，和为3)
- 在`外层j=4遍历的那一行`中
    - `j=4那一列`的第1个`+4`是遍历`物品0`，是+=`j=3那一列`的值，可以看作
        - {1，1，1，1}(四张1，和为4)，
        - {2，1，1}(一张2两张1，和为4)，
        - {1，2，1}(一张2两张1，和为4)，
        - {3，1}(一张3一张1，和为4)，
    - `j=4那一列`的第2个`+2`是遍历`物品1`，是+=`j=2那一列`的值，可以看作{1，1，2}(两张1一张2，和为4)，{2，2}(两张2，和为4)
    - `j=4那一列`的第3个`+1`是遍历`物品2`，是+=`j=1那一列`的值，可以看作{1，3}(一张1一张3，和为4)

---
`python语法：动态规划-完全背包`
```python
class Solution(object):
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        dp = [0]*(target + 1)
        # 初始化第一列
        dp[0] = 1 # 没放东西，算一种方案，便于后续累加推导
        # 递推
        for j in range(0, target + 1):
            for i in range(0, len(nums)):
                if(j >= nums[i]):
                    dp[j] = dp[j - nums[i]] + dp[j]
        return dp[-1]
```
