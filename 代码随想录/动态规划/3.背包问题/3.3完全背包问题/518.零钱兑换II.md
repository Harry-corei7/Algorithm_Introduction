`难度：中等`

- 给你一个整数数组`coins`表示不同面额的硬币，另给一个整数`amount`表示总金额。
- 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回`0`。
- 假设每一种面额的硬币`有无限个`。 
- 题目数据保证结果符合 32 位带符号整数。

- 示例 1:
  - 输入: amount = 5, coins = [1, 2, 5]
  - 输出: 4
  - 解释: 有四种方式可以凑成总金额:
    - 5=5
    - 5=2+2+1
    - 5=2+1+1+1
    - 5=1+1+1+1+1
- 示例 2:
  - 输入: amount = 3, coins = [2]
  - 输出: 0
  - 解释: 只用面额2的硬币不能凑成总金额3。
- 示例 3:
  - 输入: amount = 10, coins = [10]
  - 输出: 1
---
`python语法：动态规划-完全背包(个人理解版)`
```python
class Solution(object):
    def change(self, amount, coins):
        """
        :type amount: int
        :type coins: List[int]
        :rtype: int
        """
        bagsize = amount
        # 初始化dp数组
        dp = [[0]*(bagsize + 1) for _ in range(len(coins))]
        # 初始化第一行
        for j in range(0, bagsize + 1):
            if(j % coins[0] == 0):
                dp[0][j] = 1 # 只考虑coin[0]一种货币，有方案就是1，无就是0
        
        # 初始化第一列，这里解释为"不装"也是一种方法？(感觉与题意不符，示例二没方案是0)
        # 但是必须设置第一列为1，不然print(dp)可以看出推导有误
        for i in range(1, len(coins)):
            dp[i][0] = 1
        
        # 递推
        for i in range(1, len(coins)):
            for j in range(1, bagsize + 1):
                if(j < coins[i]):
                    dp[i][j] = dp[i-1][j] 
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j - coins[i]]
                    # 注意：不是max +coins[0] (value[0])，我们这里要的是组合方案数量
                    # 所以是累加：dp[i-1][j] + dp[i][j - coins[i]]
        return dp[-1][-1]
```
