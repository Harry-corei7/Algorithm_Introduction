1. 时间复杂度

时间复杂度描述了算法运行时间随输入规模增长的变化趋势。通常用大 O 表示法（Big O Notation）来表示。
如何观察时间复杂度？

1)找出基本操作：
- 基本操作是算法中执行次数最多的操作，比如循环、递归、条件判断等。
- 例如，在排序算法中，比较和交换是基本操作。
2)计算基本操作的执行次数：
- 分析代码中每个基本操作的执行次数。
- 重点关注循环、递归等结构。
3)忽略常数和低阶项：
- 时间复杂度关注的是增长趋势，因此常数系数和低阶项可以忽略。
- 例如，3n^2 + 2n + 1 的时间复杂度是 O(n^2)。
4)总结时间复杂度：
- 根据基本操作的执行次数，总结出算法的时间复杂度。

常见的时间复杂度
- O(1)：常数时间复杂度，操作次数与输入规模无关。
- O(log n)：对数时间复杂度，常见于二分查找。
- O(n)：线性时间复杂度，操作次数与输入规模成正比。
- O(n log n)：常见于快速排序、归并排序等高效排序算法。
- O(n^2)：平方时间复杂度，常见于双重循环。
- O(2^n)：指数时间复杂度，常见于递归问题（如斐波那契数列）。

```python
def find_max(nums):
    max_num = nums[0]          # O(1)
    for num in nums:           # 循环 n 次
        if num > max_num:      # O(1)
            max_num = num      # O(1)
    return max_num             # O(1)
```
**基本操作是 if 和赋值，执行次数为 n 次。**
**时间复杂度为 O(n)。**

------
2. 空间复杂度

空间复杂度描述了算法运行过程中所需的额外空间随输入规模增长的变化趋势。
如何观察空间复杂度？

1)找出额外空间：
- 额外空间是指除了输入数据本身占用的空间外，算法运行过程中需要的额外存储空间。
- 例如，变量、数组、递归栈等。
2)计算额外空间的使用量：
- 分析代码中使用的变量、数据结构等占用的空间。
- 重点关注递归调用、动态分配的内存等。
3)忽略常数和低阶项：
- 空间复杂度同样关注增长趋势，常数系数和低阶项可以忽略。
4)总结空间复杂度：
- 根据额外空间的使用量，总结出算法的空间复杂度。

常见的空间复杂度
- O(1)：常数空间复杂度，额外空间与输入规模无关。
- O(n)：线性空间复杂度，额外空间与输入规模成正比。
- O(n^2)：平方空间复杂度，常见于二维数组。

```python
def find_max(nums):
    max_num = nums[0]          # O(1)
    for num in nums:           # O(1)
        if num > max_num:      # O(1)
            max_num = num      # O(1)
    return max_num             # O(1)
```
**只使用了常数级别的额外空间（变量 max_num）。**
**空间复杂度为 O(1)。**
