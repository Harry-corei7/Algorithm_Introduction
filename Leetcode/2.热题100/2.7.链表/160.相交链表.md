- 给你两个单链表的头节点`headA`和`headB`，请你找出并返回两个单链表相交的起始节点。
- 如果两个链表不存在相交节点，返回`null`。
- 图示两个链表在节点`c1`开始相交：

<img width="742" height="241" alt="image" src="https://github.com/user-attachments/assets/c826a6ac-e265-48ad-b2c5-1644a457cc56" />

- 题目数据**保证**整个链式结构中不存在环。
- 注意，函数返回结果后，链表必须**保持其原始结构**。
- 自定义评测：
- 评测系统 的输入如下（你设计的程序**不适用**此输入）：
  - intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
  - listA - 第一个链表
  - listB - 第二个链表
  - skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
  - skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
- 评测系统将根据这些输入创建链式数据结构，并将两个头节点`headA`和`headB`传递给你的程序。
- 如果程序能够正确返回相交节点，那么你的解决方案将被**视作正确答案**。

---
`python语法：双指针-路程相等法，复杂度：(m + n)`
```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        # 双指针-路程相等法，复杂度：(m + n)
        cur_A = headA
        cur_B = headB
        if(headA == None or headB == None):
            return None
        while(cur_A != cur_B): # cur_A和cur_B总会相等的，要么在None，要么在交点
            if(cur_A == None): 
                cur_A = headB
            else: 
                cur_A = cur_A.next
            if(cur_B == None): 
                cur_B = headA
            else: 
                cur_B = cur_B.next
        return cur_A
```
