`难度：中等`

- 给你一个下标从`1`开始的整数数组`numbers`，该数组已按**非递减顺序排列**，请你从数组中找出满足相加之和等于目标数`target`的两个数。
- 如果设这两个数分别是`numbers[index1]`和`numbers[index2]`，则`1 <= index1 < index2 <= numbers.length`。
- 以长度为`2`的整数数组`[index1, index2]`的形式返回这两个整数的下标`index1`和`index2`。
- 你可以假设每个输入**只对应唯一的答案**，而且你**不可以**重复使用相同的元素。

- 你所设计的解决方案必须只使用常量级的额外空间。

- 示例 1：
  - 输入：numbers = [2,7,11,15], target = 9
  - 输出：[1,2]
  - 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
- 示例 2：
  - 输入：numbers = [2,3,4], target = 6
  - 输出：[1,3]
  - 解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
- 示例 3：
  - 输入：numbers = [-1,0], target = -1
  - 输出：[1,2]
  - 解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

---
`python语法`
```python
class Solution(object):
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        for cur_slow in range(0, len(numbers) - 1):
            if(numbers[cur_slow + 1] == numbers[cur_slow]): 
                if(numbers[cur_slow + 1] * 2 == target): # 剪枝的补丁：防止target是两个值相同的元素的和
                    return [cur_slow + 1, cur_slow + 2]
                else:
                    continue # 剪枝，相当于cur_slow += 1
            for cur_fast in range(cur_slow + 1, len(numbers)):
                if(numbers[cur_slow] + numbers[cur_fast] == target):
                    return [cur_slow + 1, cur_fast + 1]
```
