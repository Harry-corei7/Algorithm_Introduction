`难度：中等`

- 给定一个二叉搜索树的根节点`root`，和一个整数`k`，请你设计一个算法查找其中第`k`小的元素（`k`从 1 开始计数）。

- 示例 1：
  - 输入：root = [3,1,4,null,2], k = 1
  - 输出：1

<img width="212" height="301" alt="image" src="https://github.com/user-attachments/assets/f2c24d67-29f4-46a9-a3b1-7b347e82ab94" />

- 示例 2：
  - 输入：root = [5,3,6,2,4,null,null,1], k = 3
  - 输出：3

<img width="382" height="302" alt="image" src="https://github.com/user-attachments/assets/8dd60892-81ef-4f91-8307-37bf71eca2bb" />

---
`python语法(个人理解版)`
```python
class Solution(object):
    def minorder(self, node, res, k):
        # 根据搜索二叉树的特性，中序遍历，遍历到k个节点返回结果
        if(node.left != None):
            left_result= self.minorder(node.left, res, k) # 如果在左子树找到了结果
            if(left_result != None): return left_result # 直接返回
        res.append(node.val)
        if(len(res) == k): return res[-1]
        if(node.right != None):
            right_result = self.minorder(node.right, res, k) # 如果在右子树找到了结果
            if(right_result != None): return right_result # 直接返回

    def kthSmallest(self, root, k):
        """
        :type root: Optional[TreeNode]
        :type k: int
        :rtype: int
        """
        res = []
        result = self.minorder(root, res, k)
        return result
```
