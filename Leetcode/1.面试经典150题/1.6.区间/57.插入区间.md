`难度：中等`

- 给你一个`无重叠的`，按照区间起始端点排序的区间列表`intervals`，其中`intervals[i] = [starti, endi]`表示第`i`个区间的开始和结束，并且`intervals`按照`starti`升序排列。
- 同样给定一个区间`newInterval = [start, end]`表示另一个区间的开始和结束。
- 在`intervals`中插入区间`newInterval`，使得`intervals`依然按照`starti`升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。
- 返回插入之后的 intervals。
  - **注意**你不需要原地修改 intervals。你可以创建一个新数组然后返回它。
---
`python语法：不要在遍历数组的时候删除元素`
```python
class Solution(object):
    def insert(self, intervals, newInterval):
        """
        :type intervals: List[List[int]]
        :type newInterval: List[int]
        :rtype: List[List[int]]
        """
        # start = newInterval[0]
        # end = newInterval[1]
        # list_pop = []
        # insert_index = 0
        # for interval in intervals: # 将intervals中涉及new区间的区间全删除
        #     if(start > interval[1]):
        #         insert_index += 1 # 记录插入的index
        #         continue # 排除情况1
        #     elif(start <= interval[1] and end >= interval[0]):
        #         # intervals.remove(interval) 
        #         # 这里删除，会导致下一个需要遍历的元素被跳过
        #         list_pop.append(interval)
        # # 最后插入处理
        # if(len(list_pop) != 0): 
        #     intervals.insert(insert_index, [min(start, list_pop[0][0]), max(end, list_pop[-1][1])])
        # return intervals
        # 不要在遍历数组的时候删除元素
        result = []
        start = newInterval[0]
        end = newInterval[1]
        for interval in intervals:
            if interval[1] < start:  # 完全在左边
                result.append(interval)
            elif interval[0] > end:  # 完全在右边
                result.append(interval)
            else:  # 需要合并
                start = min(start, interval[0])
                end = max(end, interval[1])
        result.append([start, end])
        return sorted(result, key=lambda x: x[0])
```
