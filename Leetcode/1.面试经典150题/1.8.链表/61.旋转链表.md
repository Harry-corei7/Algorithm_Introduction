`难度：中等`

- 给你一个链表的头节点`head`，旋转链表，将链表每个节点向右移动`k`个位置。

- 示例 1：
  - 输入：head = [1,2,3,4,5], k = 2
  - 输出：[4,5,1,2,3]

<img width="712" height="302" alt="image" src="https://github.com/user-attachments/assets/24776052-7383-4a98-af40-c656920f4f93" />

- 示例 2：
  - 输入：head = [0,1,2], k = 4
  - 输出：[2,0,1]

<img width="472" height="542" alt="image" src="https://github.com/user-attachments/assets/7741b47d-de66-4bf7-883b-5510e06f0025" />

---
`python语法(个人理解版)`
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: Optional[ListNode]
        :type k: int
        :rtype: Optional[ListNode]
        """
        # 特殊情况
        if(head == None): return None
        if(head.next == None): return head 
        # 计算链表长度 + end指针就位
        list_length = 1
        end_cur = head
        while(end_cur.next != None):
            end_cur = end_cur.next
            list_length += 1
        # 剪枝
        if(k >= list_length): k = k % list_length
        
        # pre指针就位
        # 移动k位置的本质只需要找准位置，一次拆开，连接链表即可
        pre_break_cur = head
        for i in range(1, list_length - k):
            pre_break_cur = pre_break_cur.next
        # 移动
        end_cur.next = head
        suf_break_cur = pre_break_cur.next # 新的头节点，必须等链表连成环的时候定义，防止pre_break_cur就是end_cur
        pre_break_cur.next = None
        return suf_break_cur
```
