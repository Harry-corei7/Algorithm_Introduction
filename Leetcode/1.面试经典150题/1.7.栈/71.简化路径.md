`难度：中等`

> 原题题意
- 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为 更加简洁的规范路径。

- 在 Unix 风格的文件系统中规则如下：
  - 一个点 '.' 表示当前目录本身。
  - 此外，两个点 '..' 表示将目录切换到上一级（指向父目录）。
  - 任意多个连续的斜杠（即，'//' 或 '///'）都被视为单个斜杠 '/'。
  - 任何其他格式的点（例如，'...' 或 '....'）均被视为有效的文件/目录名称。
- 返回的 简化路径 必须遵循下述格式：
  - 始终以斜杠 '/' 开头。
  - 两个目录名之间必须只有一个斜杠 '/' 。
  - 最后一个目录名（如果存在）不能 以 '/' 结尾。
  - 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
  - 返回简化后得到的 规范路径 。
- 返回简化后得到的 规范路径 。

> 题意本质
- 给你一组由`/`隔开的字符串（忽略`空串`和`.`），请你从左到右遍历这些字符串，依次删除每个`..`及其`左侧的字符串`（模拟返回上一级目录）。

- 示例 1：
  - 输入：path = "/home/"
  - 输出："/home"
  - 解释：应删除尾随斜杠。
- 示例 2：
  - 输入：path = "/home//foo/"
  - 输出："/home/foo"
  - 解释：多个连续的斜杠被单个斜杠替换。
- 示例 3：
  - 输入：path = "/home/user/Documents/../Pictures"
  - 输出："/home/user/Pictures"
  - 解释：两个点 ".." 表示上一级目录（父目录）。
- 示例 4：
  - 输入：path = "/../"
  - 输出："/"
  - 解释：不可能从根目录上升一级目录。
- 示例 5：
  - 输入：path = "/.../a/../b/c/../d/./"
  - 输出："/.../b/d"
  - 解释："..." 在这个问题中是一个合法的目录名。
---
`python语法(1) 个人理解-逐节判断法`
- `核心思想：`
- `将除/的元素组合成一个个字符串元素，储存在数组里，相当于/和/之间只有一个元素，便于处理`
- `设置points_num计算'.'的数量，每次遍历到'/'，开始根据points_num处理元素`
```python
class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        # 设置"栈"来处理字符串
        res_path = ['/'] # 为了处理. 先将第一个的/入栈，因此在遍历时每遇到一个/，都表示这一节结束
        path += '/'  # 处理尾部的'.'和'..'，比如/home/..
        # 设置point_num记录"."的数量
        points_num = 0

        for i in range(len(path)):
            if(path[i] == "/"): 
                if(len(res_path) > 0 and res_path[-1] == "/"): # 两个目录名之间必须只有一个斜杠 '/' 。 
                    continue
                res_path.append(path[i])
                # 首先，确定上一格元素全是.
                allpoints = True
                for k in range(len(res_path[-2])):
                    if(res_path[-2][k] != '.'):
                        allpoints = False
                # 根据这一格的.数，分别进行处理
                if(points_num != 0 and points_num <= 2 and allpoints):
                    if(points_num == 1): # 字符数为1，删除本节
                        for i in range(2):
                            if(len(res_path) > 1): # 防止"/../"
                                res_path.pop(-1)
                    elif(points_num == 2): # 字符数为2，删除本节和上节
                        for i in range(4):
                            if(len(res_path) > 1): # 防止"/../"
                                res_path.pop(-1)
                points_num = 0 # 每次添加"/"意味着重新开始目录一级，'.'的数量重新统计
            elif(path[i] == "."):
                if(res_path[-1][-1] != '/'): # 只要不是'/'，都是一节的元素
                    res_path[-1] += path[i]
                else:
                    res_path.append(path[i])
                points_num += 1
            else:
                if(res_path[-1][-1] != '/'): # 只要不是'/'，都是一节的元素
                    res_path[-1] += path[i]
                else:
                    res_path.append(path[i]) # 将非"." "/"的单词直接入栈


        while(len(res_path) > 1 and res_path[-1] == "/"): # 目录名不能以 '/' 结尾。除非是目录是'/'
            res_path.pop(-1)
        
        res_path = "".join(res_path) # 字符数组转化为字符串
        return res_path
```

`python语法(2) 用split()，按`/`作为分割符，将字符串path的元素分割储存在数组，处理数组`
```python
class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """ 
        unit_path = path.split('/')
        print(unit_path)
        res_path = []
        for i in range(len(unit_path)):
            if(unit_path[i] == ""):
                continue
            elif(unit_path[i] == "."):
                continue
            elif(unit_path[i] == ".."):
                if(len(res_path) > 0): res_path.pop(-1)
                continue
            res_path.append(unit_path[i])
        res_path = "/".join(res_path)
        res_path = '/' + res_path # 补充起始的'/'
        return res_path
```
